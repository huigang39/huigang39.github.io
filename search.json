[{"path":"/2024/03/03/理论/编码器校准与偏心率校正/","content":"编码器校准与偏心率校正 编码器的校准可以手动实现，也可以自动实现。其原理就是给 UUU 相接电源正，VVV 相和 WWW 相接电源负，此时会锁定转子到 ddd 轴，也就是我们经常所说的对齐到零位。锁定后，多次读取编码器的反馈值，取其平均值，作为编码器的偏移 offset。可以把该值写到 Flash 里，每次上电读取编码器反馈值，并与偏移量 offset 求差，获取转子当前位置。无论电机的相序如何，亦或是位置传感器的初始方向怎样，上述获取编码器偏移量的方法都是有效的。 相序判断"},{"path":"/2024/03/03/理论/数学/线性代数基础/","content":"线性代数基础 解方程 矩阵运算 逆矩阵 向量空间 矩阵变换 最优解（最小二乘法） 投影与正交化 行列式 特征值、特征向量与对角化 解微分方程 矩阵的 SVD 解"},{"path":"/2024/03/03/理论/机器人学/机器人关节控制/","content":"机器人关节控制"},{"title":"永磁同步电机与磁场定向控制基础","path":"/2024/02/10/理论/永磁同步电机与磁场定向控制基础/","content":"-----施工中⚠️----- 关于永磁同步电机（Permanent Magnet Synchronous Motor, PMSM）的磁场定向控制（Field Oriented Control, FOC）算法，FOC 算法将三相无刷电机在算法上等效成一个直流电机，通过坐标变换将定子磁场进行解耦，分解成 D 轴和 Q 轴两个方向，当将 D 轴与转子磁场定向时，那么 Q 轴方向的磁场即提供电机旋转的转矩，当能实时获得转子磁场方向时，可以实时将定子磁场一直定向在 Q 轴上，这样可以得到最优的转矩，从而提高响应。当然 FOC 只是基本思想，电机控制中还有非常多改进的算法以及处理方式。 本文将主要通过 MATLAB/SIMULINK 工具搭建 PMSM 的数学模型及其 FOC 的控制仿真模型，主要涉及到相应的部分物理学、数学以及经典控制理论，并不讨论具体工程代码实现。 题外话：为何选择 Simulink 为什么要使用 Simulink 来学习呢？其实笔者之前也思考过这个问题，MATLAB 收费且体积庞大，大部分人估计都用不到里面的三成功能，而且一般人也都是用的盗版，为什么不直接手搓代码实现呢？互联网上也有很多开源的 FOC 实现（例如 ODrive、SimpleFOC 等），直接阅读这些项目的源码学习再动手实操不行吗？ 我在伺服驱动岗位工作一段时间之后，我的结论是：手搓代码可以，但很吃能力。因为电机控制不同于一般的软件开发或嵌入式开发，电机控制的重点在于控制（Control），而不在代码（Code）。这并不是说 Coding 能力不重要，代码优化好当然有助于提高系统性能，但控制才是核心，而控制又需要较强的建模能力和数学能力，而这正是 Simulink 的强项。得益于 Simulink 的强大的可视化语言体系，我们可以通过模块化的手段把数学公式、算法进行拆分，用搭积木的方式进行组合呈现。Simulink 建模本质上与代码并无区别，不过表述方式相比于文本和代码更为直观、高效：其可观测算法中公式之间的上下游关系，输入输出参数之间的交互关系，并可实时观察不同参数变化对每个局部行为的影响。从而可以让我们从繁杂的 Coding 工作中解放出来，专注于模型搭建和算法实现。等到我们的控制算法在 Simulink 仿真中基本上跑通之后，我们就可以着手开始为实际的嵌入式设备编写具体实现代码了，当然，MATLAB 也支持直接将仿真模型转化为 C/C++ 代码部署到嵌入式系统，不过貌似除了车规级的产品，一般这样干的人不多，其中具体的原因我也没有深究，想来可能是因为生成的代码不可控、难维护等原因吧。 倘若不借助 Simulink 这类工具，当然也是能够设计出完美的电机控制程序的，只不过这需要程序编写者具有较高的数学能力和控制系统的设计思维，而我们普通人借助 Simulink 这类工具，能够快速的搭建系统模型并仿真验证思路，同时初学者也可以借助 Simulink 学习电机控制中的控制精髓而避免受到具体代码实现的干扰，从而提高学习者的相应的建模和算法能力。 更重要的是，你也不想刚写好的算法因为没有事先仿真验证而直接上实机导致电机冒烟和崩到自己的手吧 : ) P.S. 调试电机时请注意安全，建议在电源输出端给电机限制合适的最大电流。 前置知识 法拉第电磁感应定律 首先我们需要复习一下小学二年级高中就学过的法拉第电磁感应定律（Faraday’s law of electromagnetic induction）中所揭示的物理规律： 任何封闭电路中感应电动势大小，等于穿过这一电路磁通量的变化率。 从法拉第大佬给我们指出的这个电磁学基本定律中可知磁场如何与电路相互作用以产生电动势（Electromotive Force, EMF），这种现象称为电磁感应。用公式可表示为： ε=−ddtΦB(1)\\varepsilon = - \\frac{d}{d t} \\Phi_{B} \\tag{1} ε=−dtd​ΦB​(1) 其中： ε\\varepsilonε：电动势，单位为伏特 VVV； ΦB\\Phi_BΦB​：磁通量，单位为韦伯 WbWbWb； ddtΦ\\frac{d}{d t} \\Phidtd​Φ：磁通量随时间的变化率。 上式中电动势 ε\\varepsilonε 的方向（公式中的负号）可由楞次定律提供。[1] 楞次定律 只使用法拉第电磁感应定律，并不容易决定感应电流方向。楞次定律（Lenz’s law）给出了一种既简单又直观地能够找到感应电流方向的方法。楞次大佬指出： 由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向。 楞次定律给判断感应电动势的方向带来了极大的方便，通过该定律我们可以快速判断出感应电流的方向进而知道感应电动势的方向。[2] 反电动势 从法拉第电磁感应定律中我们知道了感应电动势的定义，而所谓的反电动势（Counter Electromotive Force, CEMF）是指有反抗电流通过趋势的电动势，其本质上属于也感应电动势。 在永磁电机中（电机定子或转子含有永磁体才能在断电情况下产生感应电动势），感应电动势是指定子绕组通交流电后，定子线圈产生的阻碍电流变化的电动势；反电动势是电机旋转过程中，永磁体在定子主磁极上的磁场变化所引起的线圈中的电动势。 永磁电机转动时，线圈中也会产生感应电动势，这个感应电动势总要削弱电源电动势的作用，这个感应电动势即为反电动势。它的作用是阻碍线圈的转动。如果要使线圈维持原来的转动，电源就要向电机提供能量，从而实现电能转化为其它形式的能。 简单举例，在永磁电机不通电的情况下，你用手去转动永磁电机转子（如果能转动的话），这个时候电动机就会成为一个发电机，因为永磁电机的定子绕组线圈产生了感应电动势，如果你的电路系统没有做电源隔离说不定还会发现有 LED 发光了（如果有 LED 的话）。 因此在使用永磁电机的某些情况下，不要直接断开永磁电机的电源让其负载自然落下，这可能会导致永磁电机产生的反电动势过大造成电源或其他电路装置损坏。 磁通量与磁链 磁通量（Magnetic Flux）和磁链（Magnetic Linkage）是磁场理论中的两个重要概念，它们密切相关但有一些微妙的区别。 磁通量 磁通量是指磁场穿过一个给定表面的总磁场量，通常用 Φ\\PhiΦ 表示； 磁通量的大小与磁场的强度和穿过的表面积有关； 磁通量的单位是韦伯 WbWbWb。 磁链 磁链是指磁感线在一个磁路中的总长度乘以磁感线的平均强度，通常用 λ\\lambdaλ 表示； 磁链是磁通量的另一种表述，是磁通量乘以磁路的有效长度； 磁链的单位也是韦伯 WbWbWb。 综上所述，磁链和磁通量是相似的概念，都描述了磁场的特性。它们之间的主要区别在于：磁链是指磁感线在磁路中的总长度和平均强度的乘积，而磁通量则是磁场穿过一个给定表面的总磁场量。在实际应用中，两者经常交替使用，特别是在磁路分析和电机设计等领域。 欧拉公式 eix=cos⁡(x)+isin⁡(x)e^{i x} = \\cos \\left(x \\right) + i \\sin \\left(x \\right) eix=cos(x)+isin(x) 在电机控制领域中，一般变量为 θ\\thetaθ 或者 ωt\\omega tωt​ 所以欧拉公式可以写为： eiωt=cos⁡(ωt)+isin⁡(ωt)e^{i \\omega t} = \\cos \\left(\\omega t \\right) + i \\sin \\left(\\omega t \\right) eiωt=cos(ωt)+isin(ωt) ei⋅120°=cos⁡(120°)+isin⁡(120°)e^{i \\cdot 120 \\degree} = \\cos \\left(120 \\degree \\right) + i \\sin \\left(120 \\degree \\right) ei⋅120°=cos(120°)+isin(120°) ClarkeClarkeClarke 变换与 ParkParkPark​ 变换 在本节我们只讨论 ClarkeClarkeClarke 变换和 ParkParkPark 变换的纯数学推导而不关注实际物理含义及其实际应用所需考虑的附加条件，具体的应用将在后文 FOC 算法中介绍。 首先，让我们先建立一个非正交的二维平面内的静止的三相坐标系 abca b cabc，三相各轴上都有其对应的矢量，分别为 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​，且这三个矢量的运动呈现正弦波形，也就是说 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​ 是非线性的，这三个正弦函数的相位（Phase）依次相差 120°120 \\degree120°，如下图所示： 也可以这样理解： 以 abca b cabc 三个轴为平面各画一个单位圆，然后将 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​（蓝绿红）三个矢量想象成在各轴平面上做旋转运动（三个矢量的初始角度不同，也就是相位不同），旋转角度记为 θ\\thetaθ，最后再把视角拉回到上图所示的视角，这三个旋转矢量在该视角下的投影均为正弦函数。 已知这三个矢量为： {ia=imcos⁡(θ)ib=imcos⁡(θ+2π3)ic=imcos⁡(θ−2π3)\\left\\{ \\begin{array}{l} i_{a} = i_{m} \\cos \\left(\\theta \\right) \\\\ i_{b} = i_{m} \\cos \\left(\\theta + \\frac{2 \\pi}{3} \\right) \\\\ i_{c} = i_{m} \\cos \\left(\\theta - \\frac{2 \\pi}{3} \\right) \\end{array} \\right. ⎩⎨⎧​ia​=im​cos(θ)ib​=im​cos(θ+32π​)ic​=im​cos(θ−32π​)​ 其中： imi_{m}im​：正弦函数峰值，在此处为 111； θ\\thetaθ：在单位圆中的旋转角度。 通过 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​ 可以得到一个合成矢量 iδi_{\\delta}iδ​，该合成矢量可记为： iδ=ia+ib+ic=imcos⁡(θ)+imcos⁡(θ+2π3)+imcos⁡(θ−2π3)=32imcos⁡(θ)\\begin{array}{l} i_{\\delta} &amp;= i_{a} + i_{b} + i_{c} \\\\ &amp;= i_{m} \\cos \\left(\\theta \\right) + i_{m} \\cos \\left(\\theta + \\frac{2 \\pi}{3} \\right) + i_{m} \\cos \\left(\\theta - \\frac{2 \\pi}{3} \\right) \\\\ &amp;= \\frac{3}{2} i_{m} \\cos \\left(\\theta \\right) \\end{array} iδ​​=ia​+ib​+ic​=im​cos(θ)+im​cos(θ+32π​)+im​cos(θ−32π​)=23​im​cos(θ)​ 以上是我们建立的一个数学模型，这个模型可以对应到实际的物理模型上，或者说是真实存在能对应到物理含义上的，而后文做的所有变换得到的变量的目的都是围绕如何简单高效的得到 iδi_{\\delta}iδ​ 所虚拟出来的变量，并不能对应到其物理含义上。 为了简单高效的合成 iδi_{\\delta}iδ​，现在对上述 abca b cabc 坐标系做一个基变换，将其正交化为一个直角坐标系，并将其命名为 αβ\\alpha \\betaαβ​​ 坐标系，其变换公式如下： {iα=ia+cos⁡(2π3)ib+cos⁡(2π3)iciβ=sin⁡(2π3)ib−sin⁡(2π3)ic(2)\\left\\{ \\begin{array}{l} i_{\\alpha} = i_{a} + \\cos \\left(\\frac{2 \\pi}{3} \\right) i_{b} + \\cos \\left(\\frac{2 \\pi}{3} \\right) i_{c} \\\\ i_{\\beta} = \\sin \\left(\\frac{2 \\pi}{3} \\right) i_{b} - \\sin \\left(\\frac{2 \\pi}{3} \\right) i_{c} \\end{array} \\right. \\tag{2} {iα​=ia​+cos(32π​)ib​+cos(32π​)ic​iβ​=sin(32π​)ib​−sin(32π​)ic​​(2) 将式 (2)(2)(2) 写成矩阵形式为： [iαiβ]=[1−12−12032−32][iaibic](3)\\begin{bmatrix} i_{\\alpha} \\\\ i_{\\beta} \\end{bmatrix} = \\begin{bmatrix} 1 &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} \\\\ 0 &amp; \\frac{\\sqrt{3}}{2} &amp; - \\frac{\\sqrt{3}}{2} \\end{bmatrix} \\begin{bmatrix} i_{a} \\\\ i_{b} \\\\ i_{c} \\end{bmatrix} \\tag{3} [iα​iβ​​]=[10​−21​23​​​−21​−23​​​]​ia​ib​ic​​​(3) 由此，我们可知 ClarkeClarkeClarke 变换（Clarke Transform）矩阵为： C=[1−12−12032−32](4)C = \\begin{bmatrix} 1 &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} \\\\ 0 &amp; \\frac{\\sqrt{3}}{2} &amp; - \\frac{\\sqrt{3}}{2} \\end{bmatrix} \\tag{4} C=[10​−21​23​​​−21​−23​​​](4) 通过上述的 ClarkeClarkeClarke 变换将非正交的三相坐标系变换到了正交的直角坐标系，且 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​ 矢量经过 ClarkeClarkeClarke 变换后降维成了 iα,iβi_{\\alpha}, i_{\\beta}iα​,iβ​ 矢量，如下图所示： 这样一来我们就减少了一个需要控制的矢量了，但是变换后的 α,β\\alpha, \\betaα,β 矢量还是非线性（正弦）的，我们还需要一个小小的变换将其线性化（Linearization），这个变换就是 ParkParkPark 变换（Park Transform）。 所谓 ParkParkPark 变换就是将 αβ\\alpha \\betaαβ 坐标系进行旋转操作，其变换公式为： {id=iαcos⁡(θ)+iβsin⁡(θ)iq=−iqsin⁡(θ)+iβcos⁡(θ)(5)\\left\\{ \\begin{array}{l} i_{d} = i_{\\alpha} \\cos \\left(\\theta \\right) + i_{\\beta} \\sin \\left(\\theta \\right)\\\\ i_{q} = - i_{q} \\sin \\left(\\theta \\right) + i_{\\beta} \\cos \\left(\\theta \\right) \\end{array} \\right. \\tag{5} {id​=iα​cos(θ)+iβ​sin(θ)iq​=−iq​sin(θ)+iβ​cos(θ)​(5) 将式 (5)(5)(5) 写成矩阵形式为： [idiq]=[cos⁡(θ)sin⁡(θ)−sin⁡(θ)cos⁡(θ)][iαiβ](7)\\begin{bmatrix} i_{d} \\\\ i_{q} \\end{bmatrix} = \\begin{bmatrix} \\cos \\left(\\theta \\right) &amp; \\sin \\left(\\theta \\right) \\\\ - \\sin \\left(\\theta \\right) &amp; \\cos \\left(\\theta \\right) \\end{bmatrix} \\begin{bmatrix} i_{\\alpha} \\\\ i_{\\beta} \\end{bmatrix} \\tag{7} [id​iq​​]=[cos(θ)−sin(θ)​sin(θ)cos(θ)​][iα​iβ​​](7) 由此我们可以发现，其实 ParkParkPark 变换矩阵就是一个旋转矩阵（Rotation Matrix）： P=[cos⁡(θ)sin⁡(θ)−sin⁡(θ)cos⁡(θ)](8)P = \\begin{bmatrix} \\cos \\left(\\theta \\right) &amp; \\sin \\left(\\theta \\right) \\\\ - \\sin \\left(\\theta \\right) &amp; \\cos \\left(\\theta \\right) \\end{bmatrix} \\tag{8} P=[cos(θ)−sin(θ)​sin(θ)cos(θ)​](8) 最终 ParkParkPark 变换后得到的 dqd qdq 坐标系如下图所示： dqd qdq 坐标系现在是一个动态的坐标系了，且与最开始我们在abca b cabc 坐标系合成的矢量 iδi_{\\delta}iδ​ 保持相对静止。 经过这一步的变换，我们会发现，这个匀速旋转的矢量 iδi_{\\delta}iδ​ 在 dqd qdq 坐标系下变成了一个常量（因为 dqd qdq 参考系相对于 iδi_{\\delta}iδ​ 静止了），将 iδi_{\\delta}iδ​ 分解到 dqd qdq 坐标系中便得到了两个常量 id,iqi_{d}, i_{q}id​,iq​，dqd qdq 坐标系下两个控制变量 id,iqi_{d}, i_{q}id​,iq​ 已经被线性化了。 简而言之： ClarkeClarkeClarke 变换能够将静止的三相 abca b cabc 坐标系变换到静止的 αβ\\alpha \\betaαβ 坐标系下； ParkParkPark 变换能够将静止的 αβ\\alpha \\betaαβ 坐标系变换到旋转的 dqd qdq​ 坐标系下； 所谓的反变换就是将某个变换逆向计算，或者可以将反变换矩阵理解为某个变换矩阵的转置矩阵（Matrix Transpose）。 PMSM 及其数学模型 PMSM 与 BLDCM 如果你恰好了解过无刷直流电机（Brushless Direct Current Motor, BLDCM）的话，你会不会好奇为什么 PMSM 和 BLDCM 同样都拥有直流（直流电源供电）、无刷（没有用于换向的电刷）、永磁（定子或转子含有永磁体，通俗说就是磁铁）、同步（转子的运动与定子的旋转磁场同步）的特性，那为啥他们的名字会不一样呢？ 直流电源供电是指母线（Busbar）为直流电，无论是 PMSM 还是 BLDCM 都是通过类似逆变器的部件将母线直流电逆变为三相交流电输入到定子绕组内。 也可以说如果从逆变器的输入端来看，那么电机用的是直流电，如果逆变器的输出端，那么电机用的是交流电。 所以我也感觉没有必要非得给电机分出直流还是交流，电枢绕组里的电流肯定得变起来才能动。 其实我也有过这样的问题，经过我的不严谨的求证之后，综合各路大佬的文章得到如下结论： BLDCM 虽然被归为直流电机，但实际上是一种使用三相电的永磁同步电机。之所以被称为“无刷直流电机”是因为在许多应用中该电机可以替换有刷直流电机。因此，BLDCM 电机也被称为电子换向（Electronic Commutation, EC）电机，以便与包含电刷的机械换向电机进行区分； 结构：从结构上来说 BLDCM 和 PMSM 的基本结构是一样的，都是由永磁体作为转子和绕组作为定子组成的永磁电机。很多说法都是说集中绕组的是 BLDCM，分布绕组的是 PMSM，但我并没有查阅到这个结论的准确出处。 而且在多数的永磁电机设计书籍中，PMSM 是可以使用分布绕组和集中绕组这两种绕组形式的。 其实这两种绕组并没有优劣的区别，集中绕组的绕组端部尺寸更小，相电阻更小，带来的优势是效率更高、扭矩更大。分布绕组的优势是能削弱高次谐波，能更好的解决 NVH 的问题。这也是为什么航模电机更多是使用集中绕组的原因，同尺寸下集中绕组比分布绕组的功率密度要高15%，在多旋翼这种对重量锱铢必较的地方，15% 是非常大的提升另外有通过磁钢形状来判断的，不管是弧形磁钢、瓦片磁钢、抛物线磁钢、面包型磁钢其实都是永磁同步电机中常用的磁钢形状，使用什么形状更多是通过实际应用中的场景、成本等因素来决定的还有通过转子的结构来判断是表贴式永磁同步电机（Surface Mounted Permanent Magnet Synchronous Motor, SPMSM）还是内置式永磁同步电机（Interior Permanent Magnet Synchronous Motor, IPMSM），其实这两种都是永磁同步电机常用的转子结构。 所以不管是是通过集中绕组和分布绕组，还是通过磁钢形状还是转子结构来区分 PMSM 和 BLDCM 是不合适的。 转矩波动：最常见的说法是转矩波动小的是 PMSM，转矩波动大的是 BLDCM。这个说法并不正确。首先转矩波动的成因有很多，最主要的几个是——齿槽转矩引起的转矩波动、电磁转矩产生原理引起的转矩波动、电流换相引起的转矩波动。齿槽转矩引起的转矩波动，这个可以通过对定子和永磁体的优化设计，对定子转子进行斜槽斜极的方式，能将齿槽转矩降低到最大持续转矩的 2% 以内，配合抗齿槽转矩补偿算法，可以认为 BLDCM 和 PMSM 在齿槽转矩上并没有区别。而电磁转矩产生原理引起的转矩波动、电流换相引起的转矩波动是独立于齿槽转矩存在的，这两个转矩波动产生的原因，都是认为和 BLDCM 的控制器产生的是矩形波电流有关，但实际上现在使用的 FOC 控制方式，能降低 BLDCM 的转矩波动。 因此，根据转矩波动来判断是 BLDCM 还是 PMSM 也是不合适的（实际工程应用上，就转矩波动比来说，整数槽分布绕组比分数槽集中绕组的大）。 控制：在控制的的角度上来说两者的区别，那就先要说永磁电机按照感应电动势的分类：当感应电动势波形为梯形波称为 BLDCM，当感应电动势波形为正弦波时称为 PMSM。 根据这个特性，两种电机的控制器电流驱动方式也不同：BLDCM 使用方波驱动，PMSM 使用正弦波驱动。这几乎是 BLDCM 和 PMSM 最大的区别。 是区分这两种电机最直观的办法——通过分辨两种电机的反电动势波形和控制器的波形。 这可能也是“集中整距绕组的是 BLDCM，分布短距绕组的是 PMSM”这个说法的出处。 因为集中绕组的感应电动势是梯形波，分布绕组的感应电动势是正弦波。但实际上多数情况下，BLDCM 的反电动势并不完全是梯形波，也很少能设计成完美的梯形波，更多的是因为电机中的电感的存在，使得 BLDCM 的反电动势更接近正弦波。所以 BLDCM 的控制器除了使用方波驱动，也可以使用正弦波驱动。 而且现在许多 BLDCM 电机都是采用 FOC 控制，如果只是通过分辨电机的反电动势波形和控制器的驱动波形来分辨是 BLDCM 电机还是 PMSM 电机，是非常片面的。 现在已经很少有需要明确区分是 PMSM 还是 BLDCM 的场景了，传统区分 BLDCM 和 PMSM 的方法就是很粗暴的把集中绕组当成 BLDCM，把分布绕组当成PMSM。但是这种区分的方法现在看来肯定是有问题的，因为集中绕组也是永磁同步电机的一种绕组形式。至于为什么会有这种说法，可能最开始是 PMSM 被设计为使用正弦波驱动，而 BLDCM 则是由方波驱动（六步换向），为了优化效率和转矩波动，电机的反电动势波形应该和电机驱动器的驱动波形相匹配。 也正是因为这个设计，让人有 PMSM 就是贵，BLDCM 就是便宜的感觉(正弦波驱动器确实是要比方波驱动器贵，对比常见的 FOC 控制器和 ESC 控制器就知道了)。 因此，在通常情况下，可以认为有对转矩波动、高次谐波和 NVH 等进行特殊优化的电机是 PMSM（指的是工业用电机，例如伺服电机，即使使用的是集中绕组），而在说 BLDCM 时，指的是高功率密度的永磁电机（例如航模电机等稍微廉价一些的电机）。 总而言之，在绝大多数情况下， BLDCM 和 PMSM 没有真正意义上的区别。[3]或者你可以认为 PMSM 和 BLDCM 的区别不应该仅仅是本体特性的区别，还应该包含驱动方案层面的区别。[4] PMSM 的数学建模 要实现对 PMSM 的精准控制，首先需要对 PMSM 进行建模，获得其磁链方程、电压方程、转矩方程和运动方程。在此基础上，才能进一步研究其控制策略。而 PMSM 是一个非线性时变的复杂系统，各变量之间的关系及计算较为复杂，建模之后还需要用坐标变换进行简化。 磁链方程和电压方程 由于电机定转子存在相对运动，气隙磁密存在谐波，导致电磁关系复杂；若再考虑电流谐波，磁路饱和，以及电导、磁导等参数摄动，系统复杂程度将进一步提高。为简化分析，便于建模和设计对应的控制策略，往往对 PMSM 作出以下假设： 三相绕组对称，空间互差 2π3\\frac{2π}{3}32π​ 电角度； 忽略磁路饱和； 不计磁滞损耗和涡流损耗； 忽略齿槽效应，每相磁动势沿气隙正弦分布； 转子无阻尼绕组。 abca b cabc 坐标系 磁链方程 磁链方程是一个基本的电磁学方程，描述了一个闭合电路中的磁通量。它通常用来描述电感器件（例如线圈）中的磁场。 磁链方程可以用来表示一个电感器件中的磁通量与通过该线圈的电流之间的关系。它的数学表达式如下： Φ=L⋅I(2)\\Phi = L \\cdot I \\tag{2} Φ=L⋅I(2) 其中： Φ\\PhiΦ：磁通量，单位是韦伯 WbWbWb； LLL：电感，单位是亨利 HHH； III：电流，单位是安培 AAA。 这个方程表明，磁通量 Φ\\PhiΦ（描述磁场强度的物理量）与通过线圈的电流 III 成正比，且比例系数为电感 LLL。这个关系也被称为电感的自感作用。 电感除了自感作用，还会互相影响进而产生互感作用： Lm=M⋅I(3)L_{m} = M \\cdot I \\tag{3} Lm​=M⋅I(3) 其中： LmL_{m}Lm​：互感作用中的磁通量； MMM：互感系数。 根据以上电磁学基本定律，我们可将 PMSM 在三相静止 abca b cabc 坐标系下的磁链方程建立为： ψabcs=Labciabc+ψabcr(4)\\psi^{s}_{a b c} = L_{a b c} i_{a b c} + \\psi^{r}_{a b c} \\tag{4} ψabcs​=Labc​iabc​+ψabcr​(4) 其中： ψabcs\\psi^{s}_{a b c}ψabcs​：三相定子绕组磁链矢量； LabcL_{a b c}Labc​：三相定子绕组电感矩阵； iabci_{a b c}iabc​：三相定子绕组相电流矢量； ψabcr\\psi^{r}_{a b c}ψabcr​：转子永磁体磁链矢量。 上式中的三相定子绕组电感矩阵 LabcL_{a b c}Labc​ 若只考虑基波气隙磁场，电感矩阵可写为： Labc=[LaaLabLacLbaLbbLbcLcaLcbLcc](5)L_{a b c} = \\begin{bmatrix} L_{a a} &amp; L_{a b} &amp; L_{a c} \\\\ L_{b a} &amp; L_{b b} &amp; L_{b c} \\\\ L_{c a} &amp; L_{c b} &amp; L_{c c} \\end{bmatrix} \\tag{5} Labc​=​Laa​Lba​Lca​​Lab​Lbb​Lcb​​Lac​Lbc​Lcc​​​(5) 其中： Laa,Lbb,LccL_{a a}, L_{b b}, L_{c c}Laa​,Lbb​,Lcc​：三相定子绕组的自感； Lab,Lac,Lba,Lbc,Lca,LcbL_{a b}, L_{a c}, L_{b a}, L_{b c}, L_{c a}, L_{c b}Lab​,Lac​,Lba​,Lbc​,Lca​,Lcb​：三相定子绕组的互感； 由于定子绕组中的电感是转子角度的函数，所以我们可以得到： 三相定子绕组自感： {Laa=Ls+Lmcos⁡(2θe)Lbb=Ls+Lmcos⁡(2(θe−2π3))Lcc=Ls+Lmcos⁡(2(θe+2π3))(6)\\left\\{ \\begin{array}{l} L_{a a} = L_{s} + L_{m} \\cos \\left(2 \\theta_{e} \\right) \\\\ L_{b b} = L_{s} + L_{m} \\cos \\left(2 \\left(\\theta_{e} - \\frac{2 \\pi}{3} \\right) \\right) \\\\ L_{c c} = L_{s} + L_{m} \\cos \\left(2 \\left(\\theta_{e} + \\frac{2 \\pi}{3} \\right) \\right) \\end{array} \\right. \\tag{6} ⎩⎨⎧​Laa​=Ls​+Lm​cos(2θe​)Lbb​=Ls​+Lm​cos(2(θe​−32π​))Lcc​=Ls​+Lm​cos(2(θe​+32π​))​(6) 三相定子绕组互感： {Mab=Mba=−Ms−Lmcos⁡(2(θe+π6))Mbc=Mcb=−Ms−Lmcos⁡(2(θe+π6−2π3))Mca=Mac=−Ms−Lmcos⁡(2(θe+π6+2π3))(7)\\left\\{ \\begin{array}{l} M_{a b} = M_{b a} = - M_{s} - L_{m} \\cos \\left(2 \\left(\\theta_{e} + \\frac{\\pi}{6} \\right) \\right) \\\\ M_{b c} = M_{c b} = - M_{s} - L_{m} \\cos \\left(2 \\left(\\theta_{e} + \\frac{\\pi}{6} - \\frac{2 \\pi}{3} \\right) \\right) \\\\ M_{c a} = M_{a c} = - M_{s} - L_{m} \\cos \\left(2 \\left(\\theta_{e} + \\frac{\\pi}{6} + \\frac{2 \\pi}{3} \\right) \\right) \\end{array} \\right. \\tag{7} ⎩⎨⎧​Mab​=Mba​=−Ms​−Lm​cos(2(θe​+6π​))Mbc​=Mcb​=−Ms​−Lm​cos(2(θe​+6π​−32π​))Mca​=Mac​=−Ms​−Lm​cos(2(θe​+6π​+32π​))​(7) 其中： θr\\theta_{r}θr​：转子机械角度； θe\\theta_eθe​：转子电角度，且 θe=Nppθr\\theta_{e} = N_{p p} \\theta_{r}θe​=Npp​θr​（NppN_{p p}Npp​ 为转子永磁体极对数）； LsL_{s}Ls​：每相定子绕组的平均自感； LmL_{m}Lm​：自感和互感波动幅度随转子角度的变化而变化； MsM_{s}Ms​：每相定子绕组之间的平均互感。 当 θe=0\\theta_{e} = 0θe​=0 时，aaa 相定子绕组的永磁通量最大；θe=π2\\theta_{e} = \\frac{\\pi}{2}θe​=2π​ 时，aaa 相定子绕组永磁通量为 000。因此，电机的转子永磁体磁链矢量可定义为： ψabcr=ψf[cos⁡(θe)cos⁡(θe−2π3)cos⁡(θe+2π3)](8)\\psi^{r}_{a b c} = \\psi_{f} \\begin{bmatrix} \\cos \\left(\\theta_{e} \\right) \\\\ \\cos \\left(\\theta_{e} - \\frac{2 \\pi}{3} \\right) \\\\ \\cos \\left(\\theta_{e} + \\frac{2 \\pi}{3} \\right) \\end{bmatrix} \\tag{8} ψabcr​=ψf​​cos(θe​)cos(θe​−32π​)cos(θe​+32π​)​​(8) 其中： ψf\\psi_{f}ψf​：转子永磁体磁链幅值。 综上所述，在 PMSM 中，转子永磁体和三相定子绕组构成了连接每个绕组的磁链，其磁链方程矩阵形式为： [ψasψbsψcs]=[LaaLabLacLbaLbbLbcLcaLcbLcc][iaibic]+ψf[cos⁡(θe)cos⁡(θe−2π3)cos⁡(θe+2π3)](9)\\begin{bmatrix} \\psi^{s}_{a} \\\\ \\psi^{s}_{b} \\\\ \\psi^{s}_{c} \\end{bmatrix} = \\begin{bmatrix} L_{a a} &amp; L_{a b} &amp; L_{a c} \\\\ L_{b a} &amp; L_{b b} &amp; L_{b c} \\\\ L_{c a} &amp; L_{c b} &amp; L_{c c} \\end{bmatrix} \\begin{bmatrix} i_{a} \\\\ i_{b} \\\\ i_{c} \\end{bmatrix} + \\psi_{f} \\begin{bmatrix} \\cos \\left(\\theta_{e} \\right) \\\\ \\cos \\left(\\theta_{e} - \\frac{2 \\pi}{3} \\right) \\\\ \\cos \\left(\\theta_{e} + \\frac{2 \\pi}{3} \\right) \\end{bmatrix} \\tag{9} ​ψas​ψbs​ψcs​​​=​Laa​Lba​Lca​​Lab​Lbb​Lcb​​Lac​Lbc​Lcc​​​​ia​ib​ic​​​+ψf​​cos(θe​)cos(θe​−32π​)cos(θe​+32π​)​​(9) 电压方程 一般电压方程可以通过欧姆定律得到，因为 PMSM 中磁链的存在，所以还需要考虑感应电动势的存在，而感应电动势和磁链之间的关系可以通过法拉第电磁感应定律来描述。 法拉第电磁感应定律指出：一个导体中的变化磁场会导致感应电动势的产生。 当一个导体中的磁通量发生变化时，导体中会产生感应电动势。这个感应电动势导致了导体两端产生电压，具体请回顾前置知识章节中的法拉第电磁感应定律部分。 所以 PMSM 中的电压方程可定义为： uabc=Rsiabc+Dtψabcs(10)u_{a b c} = R_{s} i_{a b c} + D_{t} \\psi^{s}_{a b c} \\tag{10} uabc​=Rs​iabc​+Dt​ψabcs​(10) 其中： uabcu_{a b c}uabc​：三相定子绕组相电压矢量； RsR_{s}Rs​：各相定子绕组相电阻； DtD_{t}Dt​：微分算子，Dt=ddtD_{t} = \\frac{d}{d t}Dt​=dtd​。 ψabcr\\psi^r_{a b c}ψabcr​ 为 PMSM 的三相定子绕组磁链矢量，对其微分便可得到其各相磁通量随时间的变化率。 综上所述，可得电压方程矩阵形式为： [uaubuc]=[Rs000Rs000Rs][iaibic]+Dt[ψaψbψc](11)\\begin{bmatrix} u_{a} \\\\ u_{b} \\\\ u_{c} \\end{bmatrix} = \\begin{bmatrix} R_{s} &amp; 0 &amp; 0 \\\\ 0 &amp; R_{s} &amp; 0 \\\\ 0 &amp; 0 &amp; R_{s} \\end{bmatrix} \\begin{bmatrix} i_{a} \\\\ i_{b} \\\\ i_{c} \\end{bmatrix} + D_{t} \\begin{bmatrix} \\psi_{a} \\\\ \\psi_{b} \\\\ \\psi_{c} \\end{bmatrix} \\tag{11} ​ua​ub​uc​​​=​Rs​00​0Rs​0​00Rs​​​​ia​ib​ic​​​+Dt​​ψa​ψb​ψc​​​(11) αβ\\alpha \\betaαβ 坐标系 三相静止 abca b cabc 坐标系下的 PMSM 数学模型十分复杂，在实际应用中通常需要通过坐标变换进行简化。首先，通过 ClarkeClarkeClarke 变换，将电机方程从三相静止 abca b cabc 坐标系转换到两相静止 αβ\\alpha \\betaαβ 坐标系。 忽略电压电流零序分量，ClarkeClarkeClarke 变换矩阵为： C3s2s=23[1−12−12032−32](12)C_{\\frac{3s}{2s}} = \\frac{2}{3} \\begin{bmatrix} 1 &amp; - \\frac{1}{2} &amp; - \\frac{1}{2} \\\\ 0 &amp; \\frac{\\sqrt{3}}{2} &amp; - \\frac{\\sqrt{3}}{2} \\end{bmatrix} \\tag{12} C2s3s​​=32​[10​−21​23​​​−21​−23​​​](12) 其中： C3s2sC_{\\frac{3s}{2s}}C2s3s​​：等幅值 ClarkeClarkeClarke 变换。 因此，经过 ClarkeClarkeClarke 变换后，两相静止 αβ\\alpha \\betaαβ 坐标系下的磁链方程和电压方程为： ψαβs=Lαβiαβ+ψαβr(13)\\psi^{s}_{\\alpha \\beta} = L_{\\alpha \\beta} i_{\\alpha \\beta} + \\psi^{r}_{\\alpha \\beta} \\tag{13} ψαβs​=Lαβ​iαβ​+ψαβr​(13) uαβ=Rsiαβ+Dtψαβs(14)u_{\\alpha \\beta} = R_{s} i_{\\alpha \\beta} + D_{t} \\psi^{s}_{\\alpha \\beta} \\tag{14} uαβ​=Rs​iαβ​+Dt​ψαβs​(14) 其中： ψαβs\\psi^{s}_{\\alpha \\beta}ψαβs​：αβ\\alpha \\betaαβ 坐标系下的定子绕组磁链矢量； LαβL_{\\alpha \\beta}Lαβ​：αβ\\alpha \\betaαβ 坐标系下的定子绕组电感矩阵； iαβi_{\\alpha \\beta}iαβ​：αβ\\alpha \\betaαβ 坐标系下的定子绕组电流矢量； ψαβr\\psi^{r}_{\\alpha \\beta}ψαβr​：αβ\\alpha \\betaαβ 坐标系下的转子永磁体磁链矢量； uαβu_{\\alpha \\beta}uαβ​：αβ\\alpha \\betaαβ 坐标系下的定子绕组相电压矢量； RsR_{s}Rs​：各相定子绕组相电阻。 LαβL_{\\alpha \\beta}Lαβ​ 的矩阵形式为： Lαβ=[LααLαβLβαLββ]=[L0+L1cos⁡(2θe)L1sin⁡(2θe)L1sin⁡(2θe)L0−L1cos⁡(2θe)](15)L_{\\alpha \\beta} = \\begin{bmatrix} L_{\\alpha \\alpha} &amp; L_{\\alpha \\beta} \\\\ L_{\\beta \\alpha} &amp; L_{\\beta \\beta} \\end{bmatrix} = \\begin{bmatrix} L_{0} + L_{1} \\cos \\left(2 \\theta_{e} \\right) &amp; L_{1} \\sin \\left(2 \\theta_{e} \\right) \\\\ L_{1} \\sin \\left(2 \\theta_{e} \\right) &amp; L_{0} - L_{1} \\cos \\left(2 \\theta_{e} \\right) \\end{bmatrix} \\tag{15} Lαβ​=[Lαα​Lβα​​Lαβ​Lββ​​]=[L0​+L1​cos(2θe​)L1​sin(2θe​)​L1​sin(2θe​)L0​−L1​cos(2θe​)​](15) 其中： Lαα,LββL_{\\alpha \\alpha}, L_{\\beta \\beta}Lαα​,Lββ​：α,β\\alpha, \\betaα,β 轴自感； Lαβ,LβαL_{\\alpha \\beta}, L_{\\beta \\alpha}Lαβ​,Lβα​：α,β\\alpha, \\betaα,β 轴互感； Ld,LqL_{d}, L_{q}Ld​,Lq​：d,qd, qd,q 轴电感； L0L_{0}L0​：均值电感，且 L0=Ld+Lq2L_{0} = \\frac{L_{d} + L_{q}}{2}L0​=2Ld​+Lq​​； L1L_{1}L1​：半差电感，且 L1=Ld−Lq2L_{1} = \\frac{L_{d} - L_{q}}{2}L1​=2Ld​−Lq​​。 dqd qdq 坐标系 为消除方程中的时变参数 θe\\theta_{e}θe​，需要通过 ParkParkPark 变换，将电机方程从两相静止 αβ\\alpha \\betaαβ 坐标系转换到两相旋转 dqd qdq 坐标系。 ParkParkPark 变换矩阵为： C2s2r=[cos⁡θesin⁡θe−sin⁡θecos⁡θe](16)C_{\\frac{2s}{2r}} = \\begin{bmatrix} \\cos \\theta_{e} &amp; \\sin \\theta_{e} \\\\ - \\sin \\theta_{e} &amp; \\cos \\theta_{e} \\end{bmatrix} \\tag{16} C2r2s​​=[cosθe​−sinθe​​sinθe​cosθe​​](16) 将 ParkParkPark 变换矩阵代入式 (14)(14)(14) 中的电压方程，即可得到 dqd qdq 坐标系下的电压方程： udq=Rsidq+(Dt+jωe)(ψdqridq)=(Rs+DtLdq)idq−ωeLqiq+jωe(ψf+Ldid)(17)\\begin{align} u_{d q} &amp;= R_{s} i_{d q} + \\left(D_{t} + j \\omega_{e} \\right) \\left(\\psi^{r}_{d q} i_{d q} \\right) \\\\ &amp;= \\left(R_{s} + D_{t} L_{d q} \\right) i_{d q} - \\omega_{e} L_{q} i_{q} + j \\omega_{e} \\left(\\psi_{f} + L_{d} i_{d} \\right) \\end{align} \\tag{17} udq​​=Rs​idq​+(Dt​+jωe​)(ψdqr​idq​)=(Rs​+Dt​Ldq​)idq​−ωe​Lq​iq​+jωe​(ψf​+Ld​id​)​(17) 将式 (17)(17)(17) 还原为矩阵形式，可得 dqd qdq 坐标系下的磁链方程和电压方程： [uduq]=[Rs+DtLd−ωeLqωeLdRs+DtLq][idiq]+[0ωeψf](18)\\begin{bmatrix} u_{d} \\\\ u_{q} \\end{bmatrix} = \\begin{bmatrix} R_{s} + D_{t} L_{d} &amp; - \\omega_{e} L_{q} \\\\ \\omega_{e} L_{d} &amp; R_{s} + D_{t} L_{q} \\end{bmatrix} \\begin{bmatrix} i_{d} \\\\ i_{q} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ \\omega_{e} \\psi_{f} \\end{bmatrix} \\tag{18} [ud​uq​​]=[Rs​+Dt​Ld​ωe​Ld​​−ωe​Lq​Rs​+Dt​Lq​​][id​iq​​]+[0ωe​ψf​​](18) [ψdsψqs]=[Ld00Lq][idiq]+[ψf0](19)\\begin{bmatrix} \\psi^{s}_{d} \\\\ \\psi^{s}_{q} \\end{bmatrix} = \\begin{bmatrix} L_{d} &amp; 0 \\\\ 0 &amp; L_{q} \\end{bmatrix} \\begin{bmatrix} i_{d} \\\\ i_{q} \\end{bmatrix} + \\begin{bmatrix} \\psi_{f} \\\\ 0 \\end{bmatrix} \\tag{19} [ψds​ψqs​​]=[Ld​0​0Lq​​][id​iq​​]+[ψf​0​](19) 其中： ud,uqu_{d}, u_{q}ud​,uq​：同步坐标系 dqd qdq 坐标系下的 d,qd, qd,q 轴电压； id,iqi_{d}, i_{q}id​,iq​：同步坐标系 dqd qdq 坐标系下的 d,qd, qd,q 轴电流； ωe\\omega_{e}ωe​：转子永磁体电角速度，单位为弧度每秒 rad/srad/srad/s； ψf\\psi_{f}ψf​：永磁体磁链； RRR：定子绕组电阻。 转矩方程和运动方程 转矩方程 PMSM 的瞬时功率可定义为： P=uabcTiabc(20)P = u^{T}_{a b c} i_{a b c} \\tag{20} P=uabcT​iabc​(20) 对式 (20)(20)(20) 依次进行 ClarkeClarkeClarke 和 等幅值 ParkParkPark 变换，可得： P=32udqTidq(21)P = \\frac{3}{2} u^{T}_{d q} i_{d q} \\tag{21} P=23​udqT​idq​(21) 将式 (18)(18)(18) 中的电压方程代入式 (21)(21)(21)，可得： P=32[Rs+DtLd−ωeLqωeLdRs+DtLq][idiq]2+[0ωeψf][idiq]=32[Rs(id2+iq2)+(LdidDtid+LqiqDtiq)+ωe(ψfiq+(Ld−Lq)idiq)](22)\\begin{align} P &amp;= \\frac{3}{2} \\begin{bmatrix} R_{s} + D_{t} L_{d} &amp; - \\omega_{e} L_{q} \\\\ \\omega_{e} L_{d} &amp; R_{s} + D_{t} L_{q} \\end{bmatrix} \\begin{bmatrix} i_{d} \\\\ i_{q} \\end{bmatrix}^{2} + \\begin{bmatrix} 0 \\\\ \\omega_{e} \\psi_{f} \\end{bmatrix} \\begin{bmatrix} i_{d} \\\\ i_{q} \\end{bmatrix} \\\\ &amp;= \\frac{3}{2} \\begin{bmatrix} R_{s} \\left(i^{2}_{d} + i^{2}_{q} \\right) + \\left(L_{d} i_{d} D_{t} i_{d} + L_{q} i_{q} D_{t} i_{q} \\right) + \\omega_{e} \\left(\\psi_{f} i_{q} + \\left(L_{d} - L_{q} \\right) i_{d} i_{q} \\right) \\end{bmatrix} \\end{align} \\tag{22} P​=23​[Rs​+Dt​Ld​ωe​Ld​​−ωe​Lq​Rs​+Dt​Lq​​][id​iq​​]2+[0ωe​ψf​​][id​iq​​]=23​[Rs​(id2​+iq2​)+(Ld​id​Dt​id​+Lq​iq​Dt​iq​)+ωe​(ψf​iq​+(Ld​−Lq​)id​iq​)​]​(22) 式 (22)(22)(22) 右侧第一项对应定子绕组铜耗，第二项对应定子电感储能变化导致的功率波动，第三项对应定子电流和反电势相互作用产生的功率，也是电机输入功率耦合到转子永磁体上的功率，即电磁功率 PeP_{e}Pe​。 综上所述，电磁转矩 TeT_{e}Te​ 可记为： Te=32Npp(ψf+id(Ld−Lq))(23)T_{e} = \\frac{3}{2} N_{pp} \\left(\\psi_{f} + i_{d} \\left(L_{d} - L_{q} \\right) \\right) \\tag{23} Te​=23​Npp​(ψf​+id​(Ld​−Lq​))(23) 由式 (23)(23)(23) 可知： 对于 SPMSM，其 Ld=LqL_{d} = L_{q}Ld​=Lq​，所以其转矩方程只与 iqi_{q}iq​ 和ψf\\psi_{f}ψf​ 有关，电机转矩特性将于直流电机类似； 对于 IPMSM，Ld≠LqL_{d} e L_{q}Ld​=Lq​，其转矩方程还附带 d,qd, qd,q 轴电感的差值与 idi_{d}id​ 乘积相关项，这被称为磁阻转矩。这是由转子凸极效应引起的，该效应有利于提升电机转矩密度和扩展弱磁扩速区间。 运动方程 根据牛顿第二定律，PMSM 的转子永磁体运动方程为： JDtωr=Te−TL−BωrJ D_{t} \\omega_{r} = T_{e} - T_{L} - B \\omega_{r} JDt​ωr​=Te​−TL​−Bωr​ 其中： JJJ：电机转动惯量； TLT_{L}TL​：负载转矩； BBB：阻尼粘滞系数； ωr\\omega_{r}ωr​：转子永磁体机械角速度。 FOC 算法 FOC 的基本思想就是通过测量和控制电动机的定子电流矢量，根据磁场定向原理分别对电机的励磁电流和转矩电流进行控制，从而将三相交流电机等效为直流电 机控制。 FOC 是通过控制变频器输出电压的幅值和频率控制三相交流电机的一种变频驱动控制方法。 其主要实现步骤是通过坐标变换，将三相静止坐标系 abca b cabc 转化为两相旋转的坐标系 dqd qdq，从而使三相交流耦合的定子电流转换为相互正交，独立解耦的转矩与励磁分量，从而到达类似于他励直流电动机通过控制转矩电流直接控制转矩的目的。[5] FOC 的基本流程 对电机三相电流进行采样得到 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​； 将 ia,ib,ici_{a}, i_{b}, i_{c}ia​,ib​,ic​ 经过 ClarkeClarkeClarke 变换得到 iα,iβi_{\\alpha}, i_{\\beta}iα​,iβ​； 将 iα,iβi_{\\alpha}, i_{\\beta}iα​,iβ​ 经过 ParkParkPark 变换得到 id,iqi_{d}, i_{q}id​,iq​； 计算 id,iqi_{d}, i_{q}id​,iq​ 与其参考值（设定值）idref,iqrefi_{d_{ref}}, i_{q_{ref}}idref​​,iqref​​ 的误差 errerrerr； 将上述误差 errerrerr 输入到两个 PIDPIDPID（只用到 PIPIPI）控制器（PID Controller），得到输出的控制电压 ud,uqu_{d}, u_{q}ud​,uq​； 将 ud,uqu_{d}, u_{q}ud​,uq​ 经过反 ParkParkPark 变换得到 uα,uβu_{\\alpha}, u_{\\beta}uα​,uβ​； 用 uα,uβu_{\\alpha}, u_{\\beta}uα​,uβ​ 合成电压空间矢量，输入空间矢量脉宽调制（Space Vector Pulse Width Modulation, SVPWM）模块进行调制，输出该时刻三个半桥的状态编码值； 按照上一步输出的编码值控制三相逆变器的 MOS 管开关，驱动电机； 循环上述步骤。 12345678910graph TD; A[abc三相电流] --Clarke变换--&gt; B[αβ轴电流]; B --Park变换--&gt; C[dq轴电流]; C --与dq轴电流参考值对比--&gt; D[误差err]; D --输入--&gt; E[PI控制器]; E --输出--&gt; F[dq轴电压]; F --反Park变换--&gt; G[αβ轴电压]; G --SVPWM--&gt; H[状态编码值]; H --控制--&gt; I[MOS管开关驱动电机]; I --相电阻电流采样--&gt; A; SVPWM SVPWM 可以说是 FOC 的精髓所在， 附录 1：代码 Mathematica abca b cabc 三相坐标系矢量图绘图代码： 12345678910111213141516Graphics[ &#123; (* 绘制坐标轴 *) Arrow[&#123;&#123;0, 0&#125;, &#123;1, 0&#125;&#125;], Arrow[&#123;&#123;0, 0&#125;, &#123;Cos[2 Pi/3], Sin[2 Pi/3]&#125;&#125;], Arrow[&#123;&#123;0, 0&#125;, &#123;Cos[4 Pi/3], Sin[4 Pi/3]&#125;&#125;], Text[&quot;a&quot;, &#123;1, -0.1&#125;], Text[&quot;b&quot;, &#123;Cos[2 Pi/3] + 0.1, Sin[2 Pi/3]&#125;], Text[&quot;c&quot;, &#123;Cos[4 Pi/3] - 0.1, Sin[4 Pi/3]&#125;], (* 标注箭头之间的120°间隔 *) Text[&quot;120°&quot;, 0.15 &#123;Cos[Pi/3], Sin[Pi/3]&#125;], (* 在角度处绘制弧线 *) Circle[&#123;0, 0&#125;, 0.1, &#123;2 Pi/3, 0&#125;] &#125;, Axes -&gt; False, Frame -&gt; False, PlotRange -&gt; All] 附录 2：术语表 中文术语名 英文术语名 符号 含义 电流 Current III 电压 Voltage VVV 电阻 Resistor RRR 电感 Inductor LLL 磁通量 Magnetic Flux Φ\\PhiΦ 磁链 Magnetic Linkage λ\\lambdaλ 参考文献 法拉第电磁感应定律 - 维基百科，自由的百科全书 (wikipedia.org) ↩︎ 楞次定律 - 维基百科，自由的百科全书 (wikipedia.org) ↩︎ BLDC与PMSM电机的区别(构造、原理与控制)？ - 知乎 (zhihu.com) ↩︎ 永磁同步电机跟BLDCM有什么不同? - 知乎 (zhihu.com) ↩︎ 磁场定向控制(FOC)原理之深入浅出 ↩︎"},{"title":"混合动力汽车技术","path":"/2024/02/08/理论/汽车混合动力技术/","content":"为什么会出现混合动力汽车技术？ 化石能源燃烧造成的环境污染，碳排放引发越来越严重的温室效应，再加上能源危机，这些都对车辆的动力模式提出了转型的需求。对于普通家用汽车，最理想的替代方案便是电力驱动。而目前由于电池在能量密度和冬季续航等方面的技术瓶颈，纯电驱动尚不能很好地满足日常的行车需求；另外，与电动汽车配套的基建也是一个不小的挑战。 图1反映了目前几种主流电池类型的能量密度与传统化石燃料的对比，横轴为比能量(Wh/kg)，纵轴为体积能量密度(Wh/L)。可以看到，传统化石能源在能量携带效率方面基本上完全碾压电极材料。另一方面，由于电池是一个完整的氧化还原系统，氧化剂、还原剂都需要由车辆携带；而对于内燃机，化石燃料所需的氧化剂直接来自外界空气。这也就意味着，以目前的电池技术水平，纯电动汽车的续航能力与车辆的轻量化、紧凑性处于不可调和的矛盾。 汽车电动化的道路漫长而艰辛，但是解决环境问题和能源问题却迫在眉睫——混合动力这样的驱动模式应运而生。混合动力的中心思想是让内燃机（Internal Combustion Engine, ICE）和电动机（Electric Motor, EM）协同工作，各取所长，综合提高车辆的能量利用率，并兼顾续航能力。 图2展示了内燃机与电动机的工作特点：内燃机在低转速区间性能不佳，输出扭矩不高。这主要是因为发动机本身的转速、活塞的运动频率会影响到配气的强度和效率。而也是同样的原因，为了维持稳定的进排气，内燃机的正常运行需要保证一个最低转速，也就是怠速转速。内燃机无法实现从静止状态直接开始输出功率；而电动机则不同，电机从零速开始就能以最高水平输出扭矩，扭矩平台可以随着转速的提高一直持续到功率升至峰值，随后功率来到平台，扭矩输出开始下降。但大多数电动机存在的问题是，长时间高转速运行会存在过热的问题，因此不太适合高速巡航工况。 由此，混合动力驱动模式当中，内燃机和电动机优势互补的思路可以初见端倪：把内燃机低效的起步和低速工况交给电机；而把电机不易驾驭的高速工况交给内燃机。借助合理的控制逻辑以及特定的机械结构，两套动力系统适时介入，在各自最合适、最高效的工况下为车辆提供动力。在保障使用需求的前提下，改善整车的能量利用效率。 混合动力的类型 按照整车的电气化程度，可以分为混合动力（Hybrid Electric Vehicle, HEV）、插电式混合动力（Plug-In Hybrid Electric Vehicle, PHEV）和增程式混合动力（Range Extended Electric Vehicle, REEV）；按照内燃机和电机驱动的布局方式可以分为串联式、并联式以及功率分流式混联等几类。图3反映了不同类型混动架构的动力来源占比： 从这里不难看出混动的两大思路：从纯电车的角度出发，增加内燃机，以补足纯电的续航缺陷；或者从纯燃油车的角度出发，增加电驱系统，以改善内燃机的工作效率。 混动的核心就是尽量让发动机高效运行——要么是高速巡航的时候直驱；要么是中低速行驶时负责发电。因此，虽然混动系统依然没有彻底摆脱化石能源，但因为发动机只在高效区间运行，却间接实现了省油的效果。 按电气化程度分类 HEV混合动力汽车 HEV当中按照电机的参与程度不同又可分为三类：Micro Hybrid，Mild Hybrid和Full Hybrid。 Micro Hybrid：电动机不参与或很少参与到车辆驱动。例如用于实现自动启停功能以及制动时的能量回收。在能量回收时，电动机可以变成机械负载，充当发电机，收集过剩的动能，转化为电能储存在电池里。 Mild Hybrid：电动机仅能用于帮助车辆启动，但几乎不能实现持续的长距离的纯电里程。 Full Hybrid：车辆在纯电驱动下可以应对所有工况。电机除了用于启停、能量回收，还能和发动机共同提供输出，应对急加速（Boost）等大功率工况。 PHEV插电式混合动力汽车 顾名思义，车辆需要定期充电，从电网中获取电能存储到大容量的电池当中，以供行车时使用。而在上述HEV的电动化水平当中，车辆并不携带大容量的蓄电池，电池容量都较小，仅用于行车过程当中实时的电能充放。但是对于PHEV而言，一旦电量不足，需要完全靠发动机提供动力时，它会立马变成一个油老虎——由于同时装备两套动力系统而带来的显著增重，PHEV烧油会比普通燃油车更凶。因此，在PHEV当中，又有一个重要的技术参数：馈电油耗。 REEV增程式混合动力汽车 增程式的混合动力布局严格来说属于电动汽车的衍生物，因为内燃机与车辆传动系统没有机械连接。在任何工况下，内燃机都不会直接驱动车辆。换言之，车辆一直是靠电机驱动的，内燃机对轮边只能提供功率而不能提供扭矩。在增程式的布局当中，内燃机就是充当发电机，以保障续航。不过只需要一台小排量的内燃机作为增程器即可，因此相比传统的用于驱动车辆所装备的内燃机，大大降低了燃料消耗和废气排放。 按布局形式分类 目前混合动力布局的主流分类有串联式、并联式和功率分流混联式等几类。其中，并联式当中还包含一种被称为“Through the Street”的衍生版本。需要注意的是，这些分类并不绝对。许多厂商会将几种基础形式进行组合，开发出了多种多样、各具特色的混动系统。 串联式布局 图4所示为串联式的混合动力布局示意图。所谓串联式，是指内燃机和电机当中只有一个是直接参与驱动的。内燃机与发电机直接机械连接，内燃机驱动其产生交流电通过逆变器转换为直流电充入电池；电池再为驱动电动机供电，通过传动系统驱动车辆。 从这样的布局可以看到，内燃机与车辆的传动系不存在机械连接，在混合驱动时只用来发电，无法参与到实际的驱动当中；与传动系统有机械连接的动力输出装置只有电机。因此，串联式混动不存在内燃机与电机向传动系统叠加输出扭矩的工作模式，这是它与并联式混动的本质区别。 另一方面也可以看到，前面提到的增程式电动汽车（REEV）的原理，本质上也符合这种串联式布局的思路。至于增程式电动汽车与串联式的混动的区别，基本上可以认为增程式≈串联式的PHEV，而串联式的HEV与它们的区别在于纯电里程的量级不同。 串联式混动将发动机与传动系完全架空，这样发动机工况调节就获得了最大程度的自由，可以持续停留在高效区间，从而大大改善了燃油经济性。但串联式/增程式的局限性在于，内燃机和电机仅存在电气连接，多个环节的电能转换会导致较大的电能损耗。 串联式的混动布局应用很广，除了普通的民用车辆，铁路机车和工程车辆当中也有应用（图5） 并联式布局 并联式布局的演变版本：“Through the Street” 功率分流式混联布局 总结：混动的存在究竟有什么意义？"},{"title":"关于博客的一点感想","path":"/2024/01/14/思考/关于博客/","content":"关于博客的一点小思考 今天傍晚整理博客，删掉了好多 todo 文章，这些文章基本只写了个开头便没有后续了，这些文章或是临时起意、亦或是灵感迸发，但无论哪种，它们都是半成品，而我现在也没有写下去的欲望，所以我只留下了几篇我还想写完的文章。 聊到博客，其实我大概最早从高中时期开始自己搭建个人博客，当时不太会编程并且不了解一些技术栈，所以年少无知的我采用了 Gridea，这款软件依然是比较常规的方式：使用 Markdown 撰写文章，发布到 Github Pages 来部署静态网页。只不过这个软件把各个步骤都整合的比较简单，而且也有很多主题可供挑选，比较适合小白或者专注于内容创作的博主而无需学习繁琐的相关编程知识。也是这款软件带我走上了搭建个人博客的不归路，在此之后我慢慢摸索，逐渐开始自己使用 Hexo 等博客框架编写配置文件部署到 Github Pages，也尝试过使用其他个人博客搭建软件和 WordPress，但最终我还是选择了 Hexo 这个框架配合免费的 Github Pages，这是白嫖党的胜利（说的就是你 WordPress，会员这么贵）。 在搭建博客与撰写文章的过程中，我逐渐提高了相关的编程知识，比如了解了一些编程的知识，比如 Git 和 Github Action 的使用，同时我还提高了有关文字排版和一些设计知识，比如中英文之间需要留空白，中英文符号的使用注意事项等等。 更重要的是我看到无数在互联网上活跃的自由主义的斗士，他们传播着知识和思想，他们有的分享技术知识，有的分享生活感悟，还有的会思考社会与经济。文字是 Free（免费）的，思想是 Free（自由）的。 同时，在写博客的过程中，也是一种锻炼自己文字输出能力的过程。可能有人认为写那种公文或者材料之类的也是锻炼文字输出能力的手段，但我却不这么认为。因为这些材料也好公文也罢，它锻炼的应该都是你的语言组织和遣词造句的能力，而不是你真正心里的所思所想，它没法将你的个人的思考转化为文字，而只是在完成上级领导的任务。简单来说，它不是你内心想要写出来、分享出来的东西。而只有自己思考过的文章，才对你有精神价值，而那些所谓的材料只是给你物质上带来了价值（赚钱嘛，不寒掺）。 尽管有时我会写出一些自己后来都不想看的文章，尽管有些文章我可能永远都写不完，However，我会在写文章的那个当下，去思考，去输出，这样就足够了。更何况，有时还能写出相当不错的文章，多年之后在回过头来看看这些文章，我希望我能说出：“我艹，写的这么牛逼。”","tags":["思考"]},{"title":"租房小记","path":"/2023/12/24/生活/租房小记/","content":"租房小记 因为实习的缘故，所以我需要在上海短租一套房间，询问了公司的 HR 之后，我选择了用自如租房。 我租房的要求主要有几点： 离公司近，因为还是实习，所以不想里的太多浪费很多时间在通勤上； 价格不能太高，这个没什么可说的； 隔音效果要好，因为我经常会唱歌啥的，怕打扰到别人； 要能短租 3 个月左右，有的房源最低租一年，这点是硬要求。 其实第 1、4 点就注定了这房子不是很便宜，询问了自如管家之后发现公司附近（上海张江）就只有两套满足要求的，主要是短租这点筛掉了好多房源。而且说实话，你犹豫的话，可能别人就抢在你前面签约了。我也没有很多时间去慢慢自己找，索性就直接签约了一套。 软件签约过程中我发现不知道具体要租到什么时候，然后自如那边就建议我先签两个月的，后面和还住的话可以续约，于是我就先签了两个月的。 这套房源还是很贵的，以下是账单： 月份 房租 服务费 第一个月 ￥1833 ￥183.3 第二个月 ￥1833 ￥183.3 第三个月 ￥61.1 ￥6.11 外加押金是 ￥916.5。共计 ￥5016.31。 也就是说我如果要续租一个月大概需要 ￥1833+￥183.3=￥2016.3￥1833 + ￥183.3 = ￥2016.3￥1833+￥183.3=￥2016.3，足足两千多！好吧，其实我最开始的预算就是 ￥2000 一个月，但还是感觉太逆天了，合租都能给我干到 ￥2000 多。 我的实习工资是 ￥200 一天，一般来说一个月上班 21 天，那么我的月收入就是 ￥200×21days=￥4200￥200 \\times 21_{days} = ￥4200￥200×21days​=￥4200，减去房租还剩下 ￥4200−￥2016.3=￥2183.7￥4200 - ￥2016.3 = ￥2183.7￥4200−￥2016.3=￥2183.7，然后每天吃饭应该是 ￥5+￥20+￥20=45￥￥5 + ￥20 + ￥20 = 45￥￥5+￥20+￥20=45￥，也就是每月饮食消费为 ￥45×31days=￥1395￥45 \\times 31_{days} = ￥1395￥45×31days​=￥1395，最后总结为： 月收入 房租支出 饮食支出 结余 ￥4200 ￥2016.3 ￥1395 ￥788.7 就这我还没算水电费和其他支出，属于是倒贴了😭😭😭 只能尽量自己做饭减少饮食开支了。 补充 已经实习差不多两个多月了，公司新食堂开张之后中午和晚上吃饭就免费了，所以节省了一部分开支，现在大部分开支就只有租房费用了。而且平时同事也会请喝奶茶啥的，公司也有免费的饮料拿，所以这一块消费不算大。","tags":["生活"]},{"title":"Github 食用指南","path":"/2023/12/18/技术/Github 食用指南/","content":"Github 食用指南 序 要了解 Github，需要先了解什么是 Git，Github 和 Git 的区别又是什么？ Git：Git 是一种 VCS（Version Control System）即版本控制系统，Git 是一种分布式版本控制系统。相对的，肯定还有集中式版本控制系统，这种 VCS 的代表就是 SVN。在 2005 年，Linux 的创始人 Linus Torvalds 为了解决 Linux 内核开发中的版本控制问题，花了一周时间从头开始编写了一个革命性的新系统，并将其命名为 Git。 Github：Github 是一个基于 Git 的在线版本控制和协作平台，在 2008 年被创建，于十年之后的 2018 年被微软收购。GitHub 的目标是简化 Git 的使用和协作，使得开发者可以轻松地共享代码、跟踪问题和合并代码。GitHub 提供了一个 Web 界面，使得用户可以在浏览器中查看和管理 Git 仓库。此外，GitHub 还提供了一些额外的功能，如代码审查、项目管理工具、社区功能等。 初窥 Github 在浏览和创建开源项目之前，我们最好先要有一个 Github 账号，当然了，Github 并不会像国内网站那样不登陆就完全无法使用，即使是游客，也可以浏览和下载开源项目（不过无法参与协作）。注册账号的过程并不复杂，由于我们是个人使用所以只需要注册个人账户即可，进入官网，按照提示进行注册即可。 Tips：在国外网站中，一般 Sign up 代表注册账号，Sign in 代表登陆已有账号。 登陆账号后我们就进入了 Github 主页面（Dashboard），如果是新账号，可能是一片空白，因为你还没有什么内容可以展示。 在 GitHub 上，有一些基本的概念需要了解： 仓库（Repository）：仓库是 GitHub 用来存储项目代码的地方。一个仓库包含所有的项目文件，包括代码、文档、资源等，以及每个文件的修订历史。 分支（Branch）：在 GitHub 中，开发者可以在主分支（通常是 master 或 main）之外创建其他分支进行开发。这样可以在不影响主分支的情况下进行开发和测试。 提交（Commit）：提交是在 GitHub 上保存更改的方式。每次提交都会在当前分支上创建一个新的版本，记录下所有文件的当前状态。 推送（Push）：推送是将本地代码更改上传到 GitHub 仓库的过程。开发者可以使用命令行或者 Git 客户端工具将本地代码推送到远程仓库，使得其他人可以访问和使用这些更改。 拉取请求（Pull Request）：当开发者在分支上完成开发并准备将更改合并到主分支时，他们可以创建一个拉取请求。这是一种通知项目维护者的方式，让他们知道你已经准备好将更改合并到主分支。 合并（Merge）：当拉取请求被接受后，更改会被合并到主分支。这是将分支上的更改应用到主分支的过程。 克隆（Clone）：克隆是将 GitHub 上的仓库复制到本地计算机的过程。这样开发者就可以在本地进行开发和测试，然后将更改推送（Push）回 GitHub。 Fork：Fork 是在 GitHub 上复制别人的仓库到你的 GitHub 账户下的过程。这样你就可以在这个副本上自由地进行更改，而不会影响原始仓库。 Star：如果你喜欢某个项目，你可以给它 “Star”。这是一种表达喜爱和支持的方式，同时也可以帮助你追踪你喜欢的项目。 Issue：如果你在项目中发现了问题，或者有新的想法，你可以创建一个 Issue。这是一种与项目维护者和其他用户讨论的方式。 GitHub Actions：GitHub Actions 是 GitHub 的持续集成/持续部署（CI/CD）工具，可以自动化软件工作流程。 现在对这些概念不熟悉没关系，后面我们会经常碰到这些概念，见的多了，慢慢就能理解了。 需要注意的是，我们在了解的时候，不能只记住概念的中文词条，也要把英文词条记住，因为在你使用 Github 的时候，并不会看到中文概念词条，所以需要我们做到将英文词条直接和概念本身对应起来。在很多时候，你可能会听到开发人员说诸如：“把这个 commit push 一下”、“切一下 branch”、“提一个 PR”这种中英文混合的语句，这并不是装逼，而是很多时候用英文本身更加贴近概念本身，因为这些概念本身就是从英文世界中出来的，像这种基础概念可能还好一些，有与之对应的中文词条。而很多时候甚至都没有合适的中文词条来对应原有的概念，这就非常麻烦，所以我一直主张尽量用原本的英文词条，除非某个概念的中文词条已经深入人心，例如：“使能”。即便如此，在学习的过程中还是要尽量知道中文词条对应的英文词条是什么，这样会在后续的外网资料或者英文文档中的查阅学习更加容易一些。 从实践开始 首先，我们创建一个 Repo，也就是仓库，一般我们所谓的项目都是以 Repo 的形式存放于 Github 中的。在 Github 主页面的右上角我们可以看到一个加号，点击它之后就能看到 New repository，点击这个就进入新建仓库的页面了。 然后填入信息即可，必填信息只有 Repository name（仓库名），其他信息选填即可。 Tips：默认新建的仓库为 Public 公有仓库，即公开访问权限，可以手动改为 Private 私有仓库，不公开仓库访问权限，也就是说 Private 仓库只有自己或者本组织的用户才能访问。 剩下信息可以选填，比如 .gitignore 是 Git 的配置文件，它告诉 Git 哪些文件或目录不应该被添加到 Git 仓库中。license 是开源许可证，它定义了其他人如何使用、分发、修改或贡献你的项目。在 GitHub 中创建新的仓库时，你可以选择为你的项目添加一个开源许可证。 如果你对这些不熟悉的话，可以选择不填写。 新建仓库完成之后，我们可以看到有很多的提示命令。 我们先来关注最重要的部分，也就是这个 HTTPS 和 SSH，在这里先不看 SSH，因为使用它作为仓库链接还需要配置 SSH 密钥对才能连接，这个我们后面再配置。 Tips： HTTPS 和 SSH 是两种不同的协议，用于在你的本地机器和 GitHub 服务器之间传输数据。 HTTPS（Hyper Text Transfer Protocol Secure）是一种安全的 HTTP，它在 HTTP 和 TCP 之间添加了一个安全层（SSL 或 TLS）。这意味着所有传输的数据都会被加密，从而防止被第三方窃取。在 GitHub 中，当你使用 HTTPS 克隆仓库时，你需要每次推送时都输入你的 GitHub 用户名和密码（或使用凭据助手存储它们）。 SSH（Secure Shell）是一种网络协议，用于安全地在不安全的网络上执行网络服务，如远程登录或远程命令执行。在 GitHub 中，当你使用 SSH 克隆仓库时，你需要创建一个 SSH 密钥对，并将公钥添加到你的 GitHub 账户。这样，你就可以在推送时使用你的私钥进行身份验证，而无需输入用户名和密码。 在 GitHub 中，你可以选择使用 HTTPS 或 SSH 克隆仓库，这取决于你的具体需求和偏好。 在本地电脑创建一个文件夹，最好和你的仓库同名，当然不同名也可以。然后在该文件路径下打开 Terminal 终端执行 git init 即可初始化该文件夹为 Git 仓库。 如果你细心的话就会发现这个文件夹下多了个名为 .git 的隐藏文件夹，这里面存放的就是 Git 仓库的各种信息，没有 .git 下的各种文件，那这个文件夹就不能称之为 Git 仓库。 接着我们来新建一个文件，一般来说每个仓库都会有一个名为 README.md 的 Markdown 格式的文件。这个文件主要描述了这个项目的用途、如何配置使用以及其他信息，是使用者需要阅读的第一手文档。 这里我用命令向 README.md 文件中写入了 # demo 的文字内容。这是一种 Markdown 格式，不熟悉的读者可以自行查阅学习相关语法。当然你不使用 Markdown 语法，单纯的使用 TXT 文本也是可以的，只不过在程序员群体中，Markdown 具有很高的通用性。 注意了，接下来要展示的是 Git 最最最常用的三个命令，也就是 add、commit 和 push，掌握这三个命令的使用，基本可以应对个人开发（注意是个人开发，不涉及到团队开发）的大部分日常需求了。 可能有人会问：“你这不是还有 git branch 和 git remote 命令吗？”，不用担心这些命令基本只有第一次提交到远程仓库或者更换分支和更换远程仓库链接时才会用到，而且后续我们用 VSCode 初始化和提交仓库时就更方便了，几乎不需要使用命令。 提交完之后再去浏览器刷新看一下，就能看到我们提交的文件了，因为 Github 会在每个文件夹的首页默认显示 README 文件，所以我们就能直接看到 README.md 的内容而无需点击进去。 后续再添加、提交和推送文件就还是老三样就行了： 123456git add 你要提交的文件# git add . 可以提交所有修改过的文件（注意 add 后面是个英文句点）git commit -m &quot;你要写的提交信息&quot;# 必须要写提交信息，即使你没什么可写的，否则无法提交（当然可以使用特殊方法跳过，但是没那个必要）git push# 第一次使用 -u 指定上游的远程分支之后，后续不修改分支的情况下无需加额外参数指定 至此，基础的 Git 命令行使用就基本学习完毕了。我们要学习的不只是 Git 的命令行使用，还有它的设计思想，比如 push 之前会有一个 commit 的行为，这是一般我们使用其他软件时很少见到的，用命令行能够更加清晰的展示这些设计思想。 Github organization GitHub organization 是一种管理多个用户和仓库的方式。它可以用于团队合作，也可以用于大型开源项目。 用户管理：组织可以有多个成员，并且可以将成员分配到不同的团队。每个团队可以有不同的访问权限，例如，某些团队可能只能读取仓库，而其他团队可能可以提交更改。 仓库管理：组织可以拥有多个仓库。这些仓库可以被组织的所有成员访问，也可以被特定的团队访问。 权限管理：组织管理员可以控制成员的访问权限。例如，他们可以决定谁可以创建新的仓库，谁可以添加新的成员，等等。 统一的身份：组织可以有自己的名称、描述和头像，这可以帮助创建一个统一的品牌身份。 高级功能：对于付费用户，GitHub 组织还提供了一些高级功能，例如细粒度的权限控制、审核日志、高级安全功能等。 要创建一个新的 GitHub 组织，可以在 GitHub 网站的用户菜单中选择 “New organization”。创建组织后，你可以开始添加成员、创建仓库，以及设置团队和权限。 上图中便是设置组织的信息页面，按照要求填写即可，需要注意的是创建者可以选择组织归属权，可以设置为归属于你自己的 Github 账号，也可以选择归属于一个企业或者机构。 创建完组织之后我们就可以进入组织主页面了，下图是我以前创建过的一个组织，所以会有一些信息展示出来。 再次看到上方的功能栏就会发现稍有不同，Teams 和 People，顾名思义，在这里我们可以创建团队和添加人员到组织中。 具体的创建和添加方法按照提示来操作非常简单，这里就不多赘述了。 在组织中，最重要的事情莫过于权限管理，组织所有者需要谨慎设置组织角色的权限以避免造成不必要的麻烦。 组织所有者（Owner）可以手动修改组织成员的角色以保持不同的权限等级。具体的权限划分可以在 “Settings” 中修改。 团队协作 平常我们除了开发个人项目，可能还会需要团队多人协作去开发项目，这个时候 Github 的 Issues 和 Pull Requests 功能就派上用场了。 在 Github 仓库页面的上方，可以看到有很多功能栏，我们可以点击进入对应的功能。在这里我们暂时只用关注 Issues 和 Pull Requests，其他的留给读者自己去探索。 Issues Issues 直译过来就是『问题』，顾名思义，这里就是给项目提出各种问题的地方。一般来说，项目的使用者或者开发者会在这里提出项目的 Bug（漏洞）、Feature（特性）和建议等等，然后项目的开发者就会来解答这些 Issues。所以一般我们在使用一些开源项目、开源库遇到问题的时候，最好先来对应的仓库看一下 Issues 有没有人提过类似的问题并且有无人解答，如果有答案那最好，如果没有，那你也 + 1。 Issues 的写法还是 Markdown 语法，不同的是，在 Github 中的 Markdown，你可以 @ 别人，引用别人的回复以及其他扩展功能。更重要的是，在 Github 中，你可以直接粘贴图片，Github 会自动帮你上传到云端，然后给你一个可以访问的链接，这样就能很方便的使用 Markdown 中的图片了。 不知道你有没有注意到 Issues 页面的上方有很多按钮？其中比较显眼的是上方的搜索框，在这里我们通过关键词或者特定语句过滤我们需要的结果，其中搜索框里灰色的文字 is:issue is:open 就属于特殊语句，是 GitHub 的搜索过滤器。点击左侧的 Filters（过滤器） 就能用更多的过滤器来精准搜索。例如，is:issue is:open label:bug 将会显示所有标记为 bug 的开放 Issues。 对于我们日常使用来说，最常用的就是 open 和 closed 这两个过滤器，于是 Github 就把它们做成了按钮，直接点击就可以切换。所谓 open 就是指该问题还没有被解决，所以处于开放状态，等待能人异士来解决，而 closed 就是已经被解决的问题，所以处于关闭状态。因此如果我们想要解决问题的话，往往在 closed 里能找到类似的问题答案。 如果你是该项目的开发者或维护者，你可以给不同的 Issues 打上 Labels（标签）以区别对待。Github 贴心的为你准备了初始的几个标签，如果不够或者没有你想要的，你也可以自己添加或者删除。 此外我们还可以将 Issues 分配给某个开发者，让他来跟踪和解决该问题。如果问题被顺利解决或者时间太过久远没有人回答，可能会被 bot（机器人）（如果这个仓库有机器人的话）给自动关闭，同时我们也可以点击 Close issue 手动关闭。 当然你可以根据实际情况选择关闭该 Issues 的原因，如果问题被解决了，就选择 Close as completed，如果没有解决，就选择 Close as not planned。如果问题又『复活』了，你也可以手动再 Reopen issue 重新打开这个 Issues。 请注意，上面所描述的所有规则和使用方法，均为官方建议或者约定俗成的用法，并不是强制性的。例如明明这个问题没有被解决，你以 completed 的形式关闭了这个 Issues，这当然没有问题，只不过会给其他使用者和开发者带来困扰，使用约定俗成的用法能更好的提高开发和使用效率。 至此，基础的 Issues 功能已经足够日常团队使用了，当然个人开发项目也可以用 Issues。使用好 Issues 这个功能，能给使用者带来极大的便利，并且使用者也能给开发者反馈信息和需求，开发者和维护者可以实时的跟进需求、改进性能、修复漏洞和增加功能。 Pull Requests Pull Requests 通常被简称为 PR，这个功能与 Issues 不同，大多数情况下只有多人协作开发时才会用到。它的使用场景是这样的：假设别人 fork 了你的仓库，别人对仓库代码做了改动，无论是删除内容、修复漏洞还是添加功能，只要和你的仓库代码不一样，他就能在 Github 里提 PR 给你的仓库。我们知道 pull 在 Git 中是拉取代码的意思，request 是请求的意思，那么 Pull Requests 就是对原仓库的开发者说：“请求拉取我的代码”，然后你就可以去审查他提交的代码，如果觉得不错，你就可以将这个 PR 手动合并到原仓库中，如果不满意，你们可以讨论问题所在直到 PR 通过你的审查或者你也可以选择不将其合并到原仓库中。这个审查代码的过程也被称为 Code Review。 那么为什么不让别人直接把代码推送到原仓库呢？ 别人没有原仓库的权限，所以无法推送代码； 原仓库开发者应当保证所有改进的稳定性和代码质量。 总而言之，不要让别人在你的项目仓库乱拉 shit。 此外，PR 不仅适用于仓库与仓库之间，还适用于分支与分支之间的更改。实际上，PR 理论上就是用于提交分支间的更改的，只不过还可以在跨仓库的分支中提交更改罢了。 在下图中，我创建了一个名为 feature 的分支，并修改了其中的 README.md 文件，提交到新的远程分支之后回到浏览器就可以看到仓库页面上方出现了黄色提示栏，点击 Compare &amp; pull request，便可以创建一个 PR。 创建 PR 的页面乍一看好像和 Issues 页面差不多，都是一个 title 和 description。 但是如果把视线移到上面就会发现这里可以选择两个分支来进行 compare（比较），如果这两分支之间有『差异』，也就是说有更改，那么就可以将这些更改或者说差异添加到左边的 main 分支中。 在页面最下方还可以看到具体的更改差异，一般来说，绿色代表新增的部分，红色代表删减的部分。 检查没问题之后点击 Create pull request 即可创建 PR。 后面就是原仓库开发者的事情了，Github 会自动检查有无冲突，然后开发者需要审查提交的 PR，通过审查后将其合并到对应的分支，倘若后续后悔了，甚至还可以撤回通过的 PR（当然撤回 PR 还是以自动新建一个 PR 的方式回滚）。 Tips：现在 Github 有很多 App 和 Action 可以帮助开发者快速的辅助自动化的代码审查。 merge 方式也有好几种，这里简单介绍一下： Create a merge commit：这个选项会创建一个新的合并提交，这个提交有两个父提交（一个是你的分支的最新提交，一个是你要合并到的分支的最新提交）。这个选项会保留完整的提交历史和分支信息，但可能会使得提交历史变得复杂。 Squash and merge：这个选项会将你的所有提交压缩（squash）成一个单独的新提交，然后将这个新提交合并到你要合并到的分支。这个选项会使得提交历史更加简洁，但你会失去原始分支的提交历史。 Rebase and merge：这个选项会首先将你的分支（branch）上的所有提交（commit）应用到你要合并到的分支的最新提交上，然后再进行合并。这就好像你的更改是在最新的提交上完成的一样。这个选项可以创建一个线性的提交历史，使得历史更容易理解，但它会改变你的提交历史，可能会使得追踪更改更加困难。 Tips：方式一中所说的两个父提交并不是指两个提交（commit），如果你的一次 PR 里有 nnn 个 commit，那么会产生 n+1n+1n+1 个 commit 记录，也就是 nnn 个你的分支的 commit 记录加上 111 个你要合并到的分支的最新 commit 记录。 下图依次展示了三种方式 merge 之后（在演示中每种 merge 方式都只包含一个 commit），main 分支所产生的 Commits 记录。可以看到第一种 merge 方式确实产生了两个 commit 记录；第二种方式它会压缩所有 commit 所以最后都只有一个 commit 记录；第三个比较复杂了，虽然也只有一个 commit 记录，但是它在 main 分支产生的 commit 记录就好像直接在 main 分支进行 commit 然后 push 一样，非常强大，这个 rebase 的概念读者可以后续自行了解，这里不作介绍。 对于新手来说一般使用第一和第二种方式均可，第三种方式请谨慎使用，即使它很强大，但在你没有驾驭它的能力之前尽量不要使用。 本节结束后，读者应基本了解团队协作开发所需要使用到的 Github 基本功能，足以应对初级的团队项目开发了。 百川东到海 — Branch 上文中介绍了 PR，可能有读者深深困扰于各种 branch（分支）之间的转换以及关系，在本节中将对 branch 这一 Git 中的重要概念做一个较为深入浅出的介绍。 在 Git 中，分支可以被看作是你项目历史的一个快照或者说是一个工作流。你可以在分支上进行开发，而不会影响其他分支，这使得试验新想法变得非常容易。 当你创建一个新的分支时，Git 会创建一个指向你最新提交的指针。你可以把它想象成一个可移动的标签，表示你当前的工作进度。当你在这个分支上进行新的提交时，这个指针就会向前移动，指向新的提交。 Git 的一个主要特点是它的分支模型。Git 允许你在同一时间存在多个分支，并且可以轻松地在它们之间切换。这使得你可以在一个分支上进行新的开发，同时保持主分支的稳定性。 当你完成了在一个分支上的开发后，你可以将这个分支合并到其他分支，比如你的主分支。在合并过程中，Git 会尝试自动地将你的更改应用到目标分支。如果在这个过程中存在任何冲突，Git 会让你手动解决。 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如 SVN 等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成,无论你的版本库是 1 个文件还是 1 万个文件。 此外分支还可以解决质量问题： 比如：一个任务，两个人做。 开两个分支，谁的分支先上来，我合并谁的； 两个分支，如果其中一个人的分支有后期 bug，那么我可以切换到另一个人的分支上； 同一个人开两个分支，就是两个方案。 在下图的右侧可以看到我的博客仓库的 commit 记录，其中有绿色和蓝色两种线条，其实这就表示这是两个不同的 branch，它们交替展示就代表我在两个 branch 之间切换并提交 commit。 Tips：这是使用 VSCode 中的 Git lens 插件的可视化功能。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。 团队合作的分支看起来就像这样： 当然我们自己个人开发就没那么多讲究了，怎么舒服怎么来。 本地与远程 分支有本地和远程的区别，也就是所谓的本地分支（local branch）和远程分支（remote branch）： 本地分支是你在自己的机器上进行操作的分支。你可以在本地分支上进行开发，包括创建新的提交、修改文件等。当你满意你的更改并准备将它们分享给其他人时，你可以将你的本地分支推送到远程仓库。 远程分支是存储在远程仓库（如 GitHub）上的分支，它是多人协作的基础。当你克隆一个远程仓库时，Git 会自动创建一些远程分支来匹配远程仓库中的分支。你可以获取（fetch）远程分支来查看其他人的更改，也可以推送（push）你的本地分支来分享你的更改。 在大多数情况下，一个本地分支会有一个与之关联的远程分支，这被称为跟踪（tracking）。这使得 Git 可以知道当你执行如 git push 或 git pull 等命令时应该与哪个远程分支进行交互。 12345678# 查看本地所有分支git branch# 查看远程所有分支git branch -r# 查看本地和远程所有分支git branch -a Tips： 在 Git 中，fetch 是一个命令，用于从远程仓库获取最新的更改，但不会自动合并或修改你当前的工作。这意味着你可以随时查看远程仓库的更新，而不会影响你的本地工作。 当你执行 git fetch 命令时，Git 会连接到远程仓库，然后下载所有你还没有的数据（包括新的分支、更新的分支、新的提交等）。这些新的更改会被存储在你的本地仓库，但不会影响你的工作目录。 如果你想将这些新的更改应用到你的工作目录，你可以使用 git merge 命令来合并这些更改，或者使用 git checkout 命令来切换到一个新的分支。 当你使用 git branch -a 后，可能会疑惑：“为什么我明明有一个 feature 本地分支，但是这里没有列出来？” 实际上如果你是刚 clone 下来的仓库，本地只会有一个默认的分支（哪个分支是默认的取决于原仓库的设定），当然你可以在 clone 时手动加参数 -b 指定要克隆的远程分支，但是该仓库的其他远程分支并不会一并被创建为本地分支。 也就是说当你 clone 一个远程仓库或者执行 git fetch 命令时，Git 会获取远程仓库的所有分支，但这些远程分支并不会自动转化为本地分支。 但当你使用 git checkout feature 切换到 feature 分支的时候，如果本地不存在 feature 分支，但远程存在，Git 会自动创建一个新的本地 feature 分支，并将其设置为跟踪远程的 feature 分支。这就是为什么你需要先 checkout 到 feature 分支，然后才能在 git branch 的结果中看到它。 Tips：这里执行 git checkout feature 后返回信息：branch ‘feature’ set up to track ‘origin/feature’. Switched to a new branch ‘feature’，可以看出 Git 自动创建了一个 feature 分支并将其设置为跟踪远程的 origin/feature 分支。 remotes/origin/HEAD -&gt; origin/main 这行信息表示的是远程仓库 origin 的默认分支（或称为 HEAD 分支）是 main 分支。 在 Git 中，HEAD 是一个指向你当前正在工作的最新提交的指针。在你切换分支时，HEAD 会改变来指向新分支的最新提交。 在远程仓库中，HEAD 通常指向默认分支。在 GitHub 中，新创建的仓库的默认分支名是 main，所以 origin/HEAD 通常会指向 origin/main。 当你克隆一个远程仓库时，本地仓库的 HEAD 会自动设置为远程仓库的 HEAD 所指向的分支。所以，如果远程仓库的 HEAD 指向 origin/main，那么你克隆后的本地仓库的默认分支也会是 main 分支。 Tips： 在 Git 中，HEAD 是一个指针，指向当前检出的分支的最新提交。你可以把它看作是一个“你当前在哪里”的标记。 当你切换分支或创建新的提交时，HEAD 会自动更新以指向正确的提交。例如，如果你当前在 main 分支，并且刚刚创建了一个新的提交，HEAD 就会指向这个新的提交。如果你切换到 feature 分支，HEAD 就会更新为指向 feature 分支的最新提交。 HEAD 的一个重要用途是确定当前的工作状态。例如，git status 命令会显示你相对于 HEAD（也就是你的当前工作）有哪些更改。同样，git diff HEAD 命令会显示你的工作目录和 HEAD 之间的差异。 此外，HEAD 也常常用在其他的 Git 命令中，例如 git reset HEAD（将当前的工作状态重置为 HEAD 的状态）和 git checkout HEAD（检出 HEAD 指向的提交）。 可能有读者会困扰于 main 和 origin/main 以及 feature 和 origin/feature，名字前面带 origin 的分支与不带的有何不同呢？ 实际上，feature 和 origin/feature 通常分别代表本地的 feature 分支和远程的 feature 分支。 feature：这是你在本地创建或者从远程仓库检出（checkout）的 feature 分支。你可以在这个分支上进行提交、合并等操作，这些操作只会影响你的本地仓库。 origin/feature：这是远程仓库 origin 的 feature 分支。当你执行 git fetch 或 git pull 命令时，Git 会更新这个分支以反映远程仓库的最新状态。你不能直接在这个分支上进行提交或合并操作，但你可以使用 git merge origin/feature 或 git rebase origin/feature 命令来将这个分支的更改合并到你的本地分支。 另外需要注意的是 git fetch 和 git pull 都是用来从远程获取最新的版本。然而，这两个命令的工作方式有所不同： git fetch：这个命令会从远程获取最新的版本到本地，但它不会合并或修改你当前的工作。fetch 只是将远程的数据拉取到你的本地仓库，你需要手动合并。 git pull：这个命令实际上是 git fetch 与 git merge 的组合。它不仅会获取远程的最新版本，还会自动尝试合并到你当前的工作分支。如果存在冲突，你需要手动解决冲突。 在某些情况下，你可能只想查看远程的更改，但并不想立即合并这些更改到你的工作分支，这时你可以使用 git fetch。如果你确定要获取远程的更改并立即合并，你可以使用 git pull。 Tips： 在 Git 中，origin 是默认的远程仓库的名称。当你使用 git clone 命令克隆一个仓库时，Git 会自动创建一个名为 origin 的远程仓库别名，指向你克隆的仓库的 URL。 这只是一个约定俗成的命名规则，你完全可以使用其他的名称。例如，你可以使用 git remote add myrepo url 命令来添加一个名为 myrepo 的远程仓库。 然而，由于 origin 是默认的远程仓库名称，所以很多 Git 命令和教程都会使用它。如果你使用其他的名称，你可能需要在执行 Git 命令时指定远程仓库的名称，例如 git push myrepo master。 本节结束后我们就可以明白 Git 为什么是分布式的版本控制系统了，在 Git 的分布式模型中，每个开发者的机器上都有一个完整的仓库，包含了所有的文件和历史版本。这意味着即使远程仓库丢失，你仍然可以从任何一个开发者的机器上恢复所有的数据。 此外，因为每个开发者都有一个完整的仓库，所以大部分操作（如提交、查看历史、切换分支等）都可以在本地完成，无需连接到远程服务器，这使得 Git 的操作非常快速。 Git 可以在没有 GitHub 的情况下正常工作。实际上，Git 是一个独立的版本控制系统，它并不依赖于任何特定的在线服务。 GitHub 是一个提供 Git 仓库托管服务的平台，它提供了一些额外的功能，如 Pull Request、Issue Tracking 等，这些功能在纯粹的 Git 中并不存在。但是，你完全可以在本地使用 Git，或者使用其他的 Git 仓库托管服务，如 GitLab、Bitbucket 等。 你可以在本地创建 Git 仓库，进行提交、创建分支、合并分支等操作，这些都不需要 GitHub。如果你想与他人共享你的代码，你可以将你的 Git 仓库复制到任何可以访问的服务器上，或者使用其他的 Git 仓库托管服务。 加密通信 - SSH 如果有读者用过 ssh 工具，可能对这个比较熟悉，SSH（Secure Shell）是一个协议，用于在不安全的网络上安全地执行远程命令。ssh 命令是一个客户端程序，用于连接到运行 SSH 服务器的远程机器。 SSH 的使用前提必须要有 SSH 密钥对，你需要在本地生成一个 SSH 密钥对，包括一个私钥和一个公钥。私钥保存在你的本地机器上，公钥需要添加到你的 GitHub 账户。当你尝试连接到 GitHub 时，GitHub 会使用你的公钥来验证你的身份。 Tips：这里的 Github 可以更换为其他任何远程终端，包括但不限于各种云服务器以及局域网中的计算机。 一般的 Linux 和 Windows 系统都会自带 SSH 客户端（Windows 不自带 SSH 服务端，需要手动安装），连接 Github 的过程大致可以分为三步： 创建密钥对：执行 ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 命令，然后一路回车即可（引号内可以填写你的 Github 邮箱地址）； 复制 ~/.ssh/id_ed25519.pub 文件中的所有内容，打开浏览器，进入 “Settings” 页面，点击 “SSH and GPG keys” 选项，然后点击 “New SSH key” 即可，按照要求填入即可； 在终端执行 ssh -T git@github.com，如果弹出警告，键入 “yes” 即可。 如果没有出现错误信息，那基本就没问题了。后续就可以使用仓库中的 SSH 链接 clone 仓库了，并且不会碰到要求输入密码的问题，建议读者在本机采用 SSH 方式进行开发。 我的工作流 上文介绍了较为详细深入的内容，但在日常使用中我们并不需要经常这样『原始』的开发项目，我们完全可以采用 VSCode + Github CLI/Github Desktop 的方式简化开发。下面就简单介绍一下本人的日常开发流程。 首先，我们还是需要创建一个文件夹作为仓库来存放代码，然后使用 VSCode 打开这个文件夹，随便新建一个 README 文件。 进入 VSCode 的源代码管理功能，点击 “Publish to Github”，这里可以填写发布到 Github 的仓库名和该仓库的权限为公有还是私有。然后勾选要 push 的文件点击 “OK” 即可，打开浏览器便可看到仓库已被推送到 Github。 后续的 add、commit 和 push 操作都在 VSCode 的可视化界面操作即可，没有什么难度。 点击修改过的文件的右侧的加号就相当于 add 操作，输入信息点击 commit 便是 commit 操作，点击 “Sync Changes” 就相当于 push，非常符合人类的操作直觉。还可以在 VSCode 中直观的看到每次的 commit 远程仓库以及分支等等信息。 而 Github CLI 可以通过命令行的方式管理 Github 账号、仓库等等事务。 例如可以通过 gh 命令添加 SSH 公钥到 Github，这在 gh 中只需要一条命令，当然方便与否见仁见智，有人喜欢用命令行，有人喜欢图形化。 如果你更倾向于 GUI 图形化的操作，你可以使用 Github Desktop，这是 Github 官方推出的桌面软件，也可实现 Github CLI 的功能，不过我没有用过这个桌面应用。 至此，本文主要内容已撰写完毕。如果读者还没有习得 Git 和 Github 的使用方法，可以前去 B 站观看更多大佬制作的视频讲解；如果想了解更多细节，可以在 Github Docs 查阅文档，我推荐每一位读者遇到问题时应第一时间查阅官方文档，这是成为一名合格开发人员的必备技能。","tags":["工具"]},{"title":"对学习的思考","path":"/2023/12/11/思考/对学习的思考/","content":"对学习的思考 在我对大学（本科）工科专业学习的观念中，应该是从两个方向去学习： 一面是从基础知识学起，了解掌握该专业所需的必备基础。 譬如，工程图学，学习读图纸、画图纸的基本技能；大学物理，了解一些基本物理概念和现象；微积分、线性代数、概率论与数理统计，这些数学工具的意义在于，工程师做的事情本质上讲就是把复杂的实际问题抽象成物理模型，再将物理模型提取为数学关系，求解数学关系就可以最终解决实际工程问题；再如，最基本的计算思维和编程思想、Python 基础语法等等。然而作为学生、刚刚接触专业行业的新人，并非所有基础知识，都能和实际项目建立直观清晰的联系。 另一面是项目驱动，由想要达到的目标、做出的成品出发，反过来研究为此需要学习哪些知识，进而学习这些知识做出成品。 例如，当我想要用 Python 编写一个网络调试助手的程序，我先了解到了 GUI 编程的概念，查到了 PyQt 5 的信息，接触了面向对象编程思想，然后再学习运用这些知识，一步一步做出成品软件。再比如，在 FSAE 车队电控组工作时，我先了解我要实现的目标：赛车的拨片换挡；然后了解为实现该项目，我需要学习单片机和气压传动的知识，为单片机又需要学习 C 语言和 Keil 开发环境等知识。再从 C 语言学起，再学 STM32 单片机基本知识等，最终实现赛车拨片换挡的功能。更宏观一点，为了成为一名车辆工程师，能够具备设计汽车某一部件的能力，而学习各种专业课程，也是一个项目驱动、逆向学习的过程。 正向打基础，反向探索学习路线。二者交替以及重叠进行，逐渐完善知识体系，掌握解决复杂实际工程问题的能力。若前者进度超前于后者太多，就会有“学这门科目究竟有什么用，究竟该重点掌握该科目的哪些思想和方法？”的疑问；反过来，若是对专业基础毫无了解，做项目便近乎于“异想天开”。 然而……在学习本课程《控制工程基础》时，我个人就强烈地有第一种感觉：这门课程似乎高度抽象，完全不知所云，“一阶微分环节的传递函数”之类的概念，只是一些非常拗口难记的名词和大量非常复杂难记的数学公式，完全不知道这些式子能为我在设计汽车的哪个环节提供哪种帮助，能够解决什么样哪一类的具体问题。 这个博客系列的意义更在于，记录我曾经还“学”过这样一门学科（虽然限于个人能力，未能“习”到自动控制原理）。或许在未来的学习和工作中，某天我会恍然大悟，“这里需要用到的正是经典控制理论啊”，到那时，便可以回来查阅了。","tags":["思考","转载"],"categories":["控制"]},{"title":"为什么我折腾这些小众技术？","path":"/2023/12/10/转载/为什么我折腾这些小众技术？/","content":"转载原文： 原文","tags":["思考","转载"],"categories":["转载"]},{"title":"C 语言知识点","path":"/2023/10/18/技术/基础知识点/C 语言知识点/","content":"C 语言知识点 数据类型 基本数据类型（算术类型）：整形（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。 枚举类型：也是算术类型，常用来定义在程序中只能赋予其一定的离散整数值的变量。 void 类型：没有值的类型，通常用于函数返回值。 派生类型：数组、指针和结构体类型。 整数类型存储大小 整数类型 存储大小（字节） char 1 unsigned char 1 signed char 1 int 2 (16 bit)、4 (32/64 bit) unsigned int 2 (16 bit)、4 (32/64 bit) short 2 unsigned short 2 long 4 unsigned long 4","tags":["编程"]},{"title":"IIC 通信协议","path":"/2023/10/17/技术/通信协议/IIC/","content":"施工中","tags":["嵌入式","通信协议"]},{"title":"Linux C 多线程编程","path":"/2023/09/25/技术/Linux/Linux C 多线程编程/","content":"Linux C 多线程编程 进程与线程 进程：进程是指正在运行的程序，它拥有独立的内存空间和系统资源，不同进程之间的数据不共享。 线程：线程是进程内的执行单元，它与同一进程内的其他线程共享进程的内存空间和系统资源。 多线程的优势和应用场景 多线程是一种并发编程方式，它的优势包括： 提高程序的响应速度和运行效率（多核 CPU 下的多线程）； 充分利用 CPU 资源，提高系统的利用率； 支持多个任务并行执行，提高程序的可扩展性和可维护性。 Linux 下的多线程编程 Linux 下 C 语言多线程编程依赖于 Pthread 多线程库。Pthread 库是 Linux 的多线程库，是 POSIX 标准线程 API 的实现，它提供了一种创建和操纵线程的方法，以及一些同步机制，如互斥锁、条件变量等。 使用了 pthread 多线程库在编译链接时需要链接链接库 pthread。 线程的基本操作 创建线程","tags":["Linux","嵌入式","编程"]},{"title":"关于自我提升","path":"/2023/09/17/转载/关于自我提升/","content":"关于自我提升 自我提升很大程度上是伪命题； 作为的能力，包含两部分，第一是技术，第二是调研能力，前者是实实在在的东西，比如英语、写代码、绘画、乐器等等，后者则比较抽象（不是视频里那个抽象，就字面意思），而后者这种调研能力，或者叫做高屋建瓴的思考能力，其实需要以前者为基础； 但凡你认为的那些大神人物，其实大概率都是某方面的专家，这类人有个特点，就是首先是某个方面的专家，这是他们自信的来源，说白了，人家臭屁，因为人家牛逼。在这种能力的基础上，他们拥有了自信，于是他们可以继续探求其他自己感兴趣的东西，而在这个过程中，他们获得了抽象的调研能力； 所谓自我提升，着眼的是抽象的调研能力，说白了就是，突然间冒出个新东西来，比如之前的 ChatGPT，或者超导之类的，如何去看待这个东西，以及，如何迅速武装自己，这种其实就是调研能力，或者叫做学习能力； 学习能力，是因为你已经掌握了某个技能，一般来说是某几个技能之后，总结出来的一种方法论，这是一种总结的过程，反过来不行，你不能去演绎，也就是说，你不能妄图先找到成功学的 Silver Bullet（万金油），然后用这个 Bullet 来解决一切未来的未知问题。 总之，先问自己，我有什么拿得出手的，放在那就能镇佳一帮人的硬核技能。记住，要能镇住人的那种，才算数。 转载自 B 站 UP 主 —— Larry 想做技术大佬。","tags":["思考","转载"]},{"title":"Linux 文件系统（一） - 基本概念","path":"/2023/09/10/技术/Linux/文件系统/基本概念/","content":"Linux 文件系统（一） - 基本概念 序 倘若没有文件系统，需要访问磁盘上的数据时就需要直接读写磁盘的扇区（sector），显然这非常地繁琐。而文件系统存在的意义，就是能更 有效的组织、管理和使用 磁盘上的原始数据。 文件系统的组成","tags":["计算机","Linux","编程"]},{"title":"实习 Week 6","path":"/2023/08/26/生活/实习日志/Week 6/","content":"实习 Week 6 这周是最后一周，周日就要回学校去了。 周二的时候本来都把 QT 的 UI 改完了，结果不小心一个操作给源文件弄没了，得到的经验是慎用 git reset --hard，虽然我知道会强制删除，但是我以为我是 cp 的项目文件过来，结果操作完才发现我是 mv 过来的，彻底凉了，于是又赶紧重新去改，但是改到最后一天也没完全改完，大概只改了一半。 周四的时候工厂那边测试发现了一个 bug，就是线圈拍的强度有时候会飙升到几千，最大应该是限制到 100 才对，测试之后发现确实可以稳定复现这个 bug，不过我周五走的时候也没完全查出来是什么原因，只怀疑是主控发送的数据有误。 周五走的时候和项目组的人都打了声招呼，中午还和他们出去吃了个饭，收拾东西的时候发现还有个在这买的本子没用呢，本来是想开会的时候做笔记的，后来发现根本没必要，索性直接把本子给他们用了，有时候可以画画思路啥的。Terry 说还留个纪念，笑死。 走之前，和 Terry 交接了事情，和东哥也说了下 QT UI 的情况，把已经改过的源码发给他了，任务交接完就回去了，最后一天班算是上完了。 周六就不出去玩了，准备晚上在小区附近转转就行了，毕竟是最后一晚了。","tags":["实习"]},{"title":"实习 Week 5","path":"/2023/08/21/生活/实习日志/Week 5/","content":"实习 Week 5 这周的工作任务主要是继续修复了液位传感器的 bug 和分析新电源的限制关系以及解决人机交互部分的 QT 界面的不规范的标签问题。 上周解决的液位传感器 bug，其实还没有完全解决，因为二次测试的时候发现，液位显示好像是反过来的，结果发现是传感器检测到液位输出低电平，确实是相反的，于是我又改了一下，这下测试好几遍确认是没有问题了。然后是 Terry 给我了新电源的限制表和程序限制表，需要分析下程序限制有没有在新电源的限制之下，如果超出了电源限制肯定是不行的，我整理了下数据，用 Python 花了张图，可以直观的展示限制关系，还是有部分超出限制的，说明有这方面的问题。另外是 QT 的标签名不规范的问题，这个工作量比较大，但是不是很复杂，花费的时间也比较久，估计下周才能完成。 周五晚上还去了个 B 友那拿了免费的星瞳贴纸，他们应该是几个全国各地的富哥出来玩，开的全是痛车，属实给了我一点小小的二次元震撼。 周六日又是一个人骑车瞎转的两天，周六去的比较远，直接干到了滴水湖和海边，不过入海口的海太浑浊了，我的建议是不要去，很脏。周日去了前滩、后滩和世博园那边，那边的绿道还是很不错的，风景很好。","tags":["实习"]},{"title":"实习 Week 4","path":"/2023/08/21/生活/实习日志/Week 4/","content":"实习 Week 4 这周主要的工作任务是测试主控的功能，对照着测试文档，在串口输入对应的功能命令观察主控是否按预期工作，测试后发现了液位传感器有问题，并不能按照预期的输出液位数据。然后就开始修 bug 工作了，原因是代码中液位传感器的结构体没有对应上，错位了，修改之后就可以正常工作了。除此自外还去测了新电源的强度和电压的对应关系，不过这个比较逆天，PC 端软件是通过 CAN 总线发送的查询电压信号，每次查询时间一长主控就寄了，就得重启，所以花了好久才测完。 周六因为同行学长说要做排骨汤，所以也就没有出门了。 周日的时候上午一个人跑去 KTV 唱了三个小时的歌，是真的舒服，唱到一点钟，买了杯喜茶（原神联动）喝完之后就直接骑着共享单车瞎鸡儿骑了，骑了好久发现在往南骑，于是干脆直接渡个江到闵行另一边去了，最后是骑到了上海交通大学的一个产业园，骑不动了就坐地铁回来了。","tags":["实习"]},{"title":"实习 Week 3","path":"/2023/08/21/生活/实习日志/Week 3/","content":"实习 Week 3 这周在工作任务主要是分析机器的功率限制表，对其中缺失的数据进行插值补全，并对其进行多项式拟合得到函数。但是只能说这个数据表比较抽象，有规律但不多，比较折磨。最后通过 Origin 强行多项式暴力拟合六阶多项式才能勉强比较符合数据样点。 其次的任务有介绍 PlantUML 工具，换成 Obsidian 写介绍文档了，也可以用幻灯片样式展示，感觉 slidev 语法还是有点复杂，不如纯 Markdown 来的简约方便，而且迁移成本不高。在公司会议室主要给软件部门的几个人现场讲了一下 PlantUML 的工具，后面 Aric 也来了，问了一些问题，觉得 PlantUML 非常不错，可以在公司推广，会议录屏也发到软件部门了，我也上传到我的 B 站账号了。 周五的时候拿到了主控的代码，不过没来的及看，计划下周看看。 周六和几个学长出去看遇见博物馆的达利艺术画展，达利属于是超现实主义的那一派了，主题有“马”、“爱丽丝梦游仙境”、“但丁的《神曲》”和“科学技术”，应该是按照时间顺序来展览的，影响比较深刻的是他的画总是会有一些共同的元素，例如“爱丽丝梦游仙境”为主题的插画里的跳绳的爱丽丝贯穿了整个插画系列，此外还有在“科学技术主题”和“神曲”主题里经常出现的拐杖。 画展看完之后就去附近的 EVA 雕像转了转，附近也有好多其他动漫/特摄里的人物雕像，不过还是初号机的那个雕像最大。接着就是公园转了一圈，吃饭，到晚上回家的时候已经是 11 点多了。 周日大上午又去和两个学长看电机展，不过很多台子都撤走了，果然看展览还是展览开始的第二天最好。中午跑去中华艺术宫附近吃了乌克兰餐厅，感觉还不错，比昨天的日餐好吃。下午其中两个学长就要回苏州去了，因此我们也就都回去了。","tags":["实习"]},{"title":"Git 中的 Windows 与 Linux 的换行符兼容问题","path":"/2023/08/12/技术/问题总结/Git 中的 Windows 与 Linux 的换行符兼容问题/","content":"Git 中的 Windows 与 Linux 的换行符兼容问题 前置知识 众所周知，在不同的操作系统中，行结束符的表示方式是不同的： 在 Unix、Linux 和类 Unix 系统中（如 macOS），行结束符用换行符（LF）表示。 在早期的 Mac OS（9 及以前）中，行结束符用回车符（CR）表示。 在 Windows 系统中，行结束符用回车符（CR）后跟换行符（LF）的组合表示。 因此，Windows 系统中的文本文件中每行的结尾都是由 CRLF 组成的（即回车换行）。 在某些情况下，当在 Unix 或 Linux 系统中处理 Windows 风格的文本文件时，CRLF 换行符可能会引发问题，例如在运行脚本或解析文件时。在这些情况下，需要进行换行符的转换，将 CRLF 转换为 LF，以使其与 Unix 系统兼容。 可以使用一些工具或命令来进行换行符转换，例如 dos2unix 或 sed 命令。这些工具可以将 Windows 风格的 CRLF 换行符转换为 Unix 风格的 LF 换行符。 问题分析 这天我在准备使用 Docker 配置 buildroot 时，发现使用 -v 参数挂载宿主机的目录或文件到容器内部，然后进到容器里编译会提示 No such file or directory 的经典报错，稍微分析了一下，应该是行结束符的问题，因为我是在 Windows 上先克隆仓库，然后再把本地仓库映射到容器内。这样克隆下来的文件的行结束符都是 Windows 风格的 CRLF，再进到容器内使用编译命令的时候，是在 Linux 下执行的，所以会导致兼容性问题。 解决方案 解决办法也很简单，只要使用 Linux 系统克隆下来仓库就好了，我这里使用的是 WSL 克隆到 Windows 文件系统内，然后再创建容器映射文件夹就没问题了。当然也可以使用 Docker 建一个 Linux 容器，然后把仓库克隆下来再导出到 Windows 文件系统下。 总结 Docker 还是在 Linux 下使用更好，Windows 下的 Docker Desktop 还有比较多的问题。","tags":["问题"]},{"title":"PlantUML 入门指南","path":"/2023/08/01/技术/PlantUML 入门指南/","content":"介绍 PlantUML 是一款开源的 UML 图绘制工具，支持通过文本来生成图形。 PlantUML 相对于传统的图形编辑器，有许多优点： 简单易用 使用简单的文本语法来描述图形，无需复杂的图形编辑器，即可绘制各种类型的 UML 图 版本控制 可以纳入版本控制系统，方便多人协作和管理 可拓展性 支持插件和自定义扩展，可以满足不同用户的需求 可视效果 绘制的图形具有高清晰度和美观的效果，可以直接嵌入到文档和演示中，方便分享和展示 安装 软件要求 Java: 运行 PlantUML 的必需条件。 Graphviz-dot:（可选）, 但是建议安装（如果想绘制除时序图和活动图以外的图, 就需要安装 Graphviz 软件）。 VS Code 拓展（可选）：PlantUML 插件，ALT + D 可预览图像, 可导出源文件为 png，svg，pdf 等格式。 Debian/Ubuntu： 1sudo apt install plantuml Windows： 12scoop bucket add extrasscoop install extras/plantuml 使用 序列图 1234567891011121314151617@startumlparticipant Participant as Foo #redactor Actor as Foo1 #blueboundary Boundary as Foo2control Control as Foo3entity Entity as Foo4database Database as Foo5collections Collections as Foo6queue Queue as Foo7Foo -&gt; Foo1 : To actor Foo --&gt; Foo2 : To boundaryFoo -&gt; Foo3 : To controlFoo -&gt; Foo4 : To entityFoo -&gt; Foo5 : To databaseFoo -&gt; Foo6 : To collectionsFoo -&gt; Foo7: To queue@enduml -&gt;：实线连接，--&gt;：虚线连接 可通过关键字声明参与者，并改变参与者的表示形状 用例图 123456789101112131415161718@startumlleft to right directionactor Guest as gpackage Professional &#123; actor Chef as c actor &quot;Food Critic&quot; as fc&#125;package Restaurant &#123; usecase &quot;Eat Food&quot; as UC1 usecase &quot;Pay for Food&quot; as UC2 usecase &quot;Drink&quot; as UC3 usecase &quot;Review&quot; as UC4&#125;fc --&gt; UC4g --&gt; UC1g --&gt; UC2g --&gt; UC3@enduml left to right direction：设置为左右布局 类图 123456789101112131415161718192021@startumlclass BaseClassnamespace net.dummy #DDDDDD &#123; .BaseClass &lt;|-- Person Meeting o-- Person note top of Person : Test. .BaseClass &lt;|- Meeting&#125;namespace net.foo &#123; net.dummy.Person &lt;|- Person .BaseClass &lt;|-- Person net.dummy.Meeting o-- Person&#125;BaseClass &lt;|-- net.unused.Person@enduml namespace：命名空间 &lt;|--：泛化关系 *--：组合关系 o--：聚合关系 组件图 123456789101112131415161718192021222324252627282930@startumlPackage &quot;Some Group&quot; &#123; HTTP - [First Component] [Another Component]&#125;Node &quot;Other Groups&quot; &#123; FTP - [Second Component] [First Component] --&gt; FTP&#125;Cloud &#123; [Example 1]&#125;Database &quot;MySql&quot; &#123; Folder &quot;This is my folder&quot; &#123; [Folder 3] &#125; Frame &quot;Foo&quot; &#123; [Frame 4] &#125;&#125;[Another Component] --&gt; [Example 1][Example 1] --&gt; [Folder 3][Folder 3] --&gt; [Frame 4]@enduml 对象图 1234567891011121314@startumlObject LondonObject WashingtonObject BerlinObject NewYorkMap CapitalCity &#123; UK *-&gt; London USA *--&gt; Washington Germany *---&gt; Berlin&#125;NewYork --&gt; CapitalCity::USA@enduml 活动图 123456789101112131415@startumlStartRepeat : 测试某事; If (发生错误?) then (没有) #palegreen : 好的; Break Endif -&gt;not ok; : 弹窗 &quot;文本过长错误&quot;;Repeat while (某事发生文本过长错误?) is (是的) not (不是)-&gt;//合并步骤//;: 弹窗 &quot;成功！&quot;;Stop@enduml 部署图 123456789101112131415161718192021222324252627282930313233343536@startumlActor foo 1Actor foo 2foo 1 &lt;-0-&gt; foo 2foo 1 &lt;-(0)-&gt; foo 2 (ac 1) -le (0)-&gt; left 1Ac 1 -ri (0)-&gt; right 1Ac 1 .up (0).&gt; up 1Ac 1 ~up (0)~&gt; up 2Ac 1 -do (0)-&gt; down 1Ac 1 -do (0)-&gt; down 2 Actor 1 -0)- actor 2 Component comp 1Component comp 2Comp 1 *-0)-+ comp 2[comp 3] &lt;--&gt;&gt; [comp 4]Boundary b 1Control c 1B 1 -(0)- c 1Component comp 1Interface interf 1Comp 1 #~~( interf 1: mode 1 actor: -0)- fooa 1: mode 1 actorl: -ri 0)- foo 1 l[component 1] 0)-(0-(0 [componentC]() component 3 )-0-(0 &quot;foo&quot; [componentC][aze 1] #--&gt;&gt; [aze 2]@enduml 状态图 1234567891011121314151617181920@startuml[*] -&gt; State 1State 1 --&gt; State 2 : SucceededState 1 --&gt; [*] : AbortedState 2 --&gt; State 3 : SucceededState 2 --&gt; [*] : AbortedState State 3 &#123; State &quot;Accumulate Enough Data&quot; as long 1 Long 1 : Just a test [*] --&gt; long 1 Long 1 --&gt; long 1 : New Data Long 1 --&gt; ProcessData : Enough Data State 2 --&gt; [H]: Resume&#125;State 3 --&gt; State 2 : PauseState 2 --&gt; State 3[H*]: DeepResumeState 3 --&gt; State 3 : FailedState 3 --&gt; [*] : Succeeded / Save ResultState 3 --&gt; [*] : Aborted@enduml 时序图 1234567891011121314151617181920212223@startumlClock &quot;Clock_0&quot; as C 0 with period 50Clock &quot;Clock_1&quot; as C 1 with period 50 pulse 15 offset 10Binary &quot;Binary&quot; as BConcise &quot;Concise&quot; as CRobust &quot;Robust&quot; as RAnalog &quot;Analog&quot; as A@0C is IdleR is IdleA is 0@100B is highC is WaitingR is ProcessingA is 3@300R is WaitingA is 1@enduml 其他 PlantUML 可以集成在各种外部工具中，例如可以集成到 Doxygen 、Markdown、Word 等工具中。 官方网站：plantuml. Com C++ 源码转 PlantUML 工具","tags":["工具"]},{"title":"实习 Week 2","path":"/2023/07/29/生活/实习日志/Week 2/","content":"实习 Week 2 上一周 Terry 让我可以早会上讲讲 PlantUML，结果周日晚上我还真准备了一个 PPT，还是用的 Slidev 做的，部署到了 Vercel，可以在线浏览器打开播放，结果没提这件事，比较难绷，不过就当是复习了一下 Sildev 了。 这一周正式开始了写代码，首先是解决线圈拍的 OLED 存在的烧屏隐患，因为线圈拍会长时间显示同一温度和强度，可能会导致 OLED 老化不均匀存在色差，最后采用了经典的移位显示方案，就是让显示内容隔一段时间就位移一段距离，类似于现在手机的息屏显示的解决方案；其次是一个按键的问题，原本的是释放按键触发，需要改为按下触发，这个比较好改，基本上一会就改好了，然后就把代码 Push 到项目的 Gitlab 上了。 后面几天，同行学长的 Leader 给了个任务，用 STM32 读取 AS7262 颜色光谱传感器的数据，我们搞了一天半都没成功，后来 Leader 给我们找了个人看了下，原来是 I2C 读写的时候，设备地址还不一样，用示波器抓了一会就发现了，最后算是搞定了。 周六的时候，本来想去公安局办理护照，结果最后一站地铁时候发现忘带身份证了，索性直接去陆家嘴玩，直接从地铁站出来骑上小黄车冲到了黄浦江边，因为当时还是蒙蒙细雨，路上也没有很多人，刚好练练我刚学会的自行车，感觉还是不错的，基本上只要人和车不是特别多的地方没有啥问题了，一口气骑了十多公里逛了一圈陆家嘴到了江边，做了轮渡到对面，东方明珠附近人是真的多，只能到下一个渡口坐船过去了，然后找了半天学长推荐的大壶春生煎，结果发现就在上周去的外滩附近，太难绷了，但是人太多就没去，在隔壁一家吃了，感觉一般，但也不是非常贵，还好。 周日一个人骑共享单车去了傅立叶智能的公司所在地，是真的又远又热，而且路上很多的小桥，就导致有很多的上下坡，骑车比较累，不过主要也是为了看风景。到的时候发现园区关门，也没想着进去，就在附近转了一圈就坐地铁回去了，不过那里好像是张江高科的一个分部，貌似稚晖君的智元机器人公司就在傅立叶智能隔壁的园区。","tags":["实习"]},{"title":"OLED 防烧屏方案","path":"/2023/07/21/生活/实习日志/OLED 防烧屏方案/","content":"OLED 防烧屏方案 动态显示：尽量避免长时间显示同一图像。例如，可以设计一个动态的温度显示界面，比如让温度数值在屏幕上移动，或者定期改变显示的位置。 屏幕休眠：如果长时间不需要查看，可以让屏幕进入休眠状态。可以设置一个定时器，如果一段时间内没有操作，就自动关闭屏幕。 降低亮度：OLED 屏幕的烧屏程度与亮度有关。降低屏幕亮度可以减缓像素的老化，从而延长屏幕的使用寿命。 使用屏幕保护程序：在不使用屏幕时，可以运行一个屏幕保护程序，比如显示一些动态的图案，以防止某些像素长时间处于高亮度状态。 定期刷新全屏：可以定期进行全屏刷新，即让所有像素都短暂地亮起，然后再显示正常的图像。这样可以均匀地分布像素的使用，避免某些像素过度老化。","tags":["嵌入式","STM32"]},{"title":"实习 Week 1","path":"/2023/07/18/生活/实习日志/Week 1/","content":"实习 Week 1 第一天上班，早上七点半就起了，刷完牙洗完脸差不多八点了，然后和同行的学长骑共享单车去了公司，自行车还不是很熟练。 到了公司，行政人员先和我们签了个实习合同，然后把我们领到工位上，但是这边是电子工程师的工位，我们主要是来做嵌入式软件开发的，所以后来和老师说了下，老师就给 Aric （技术总管）打了个电话，Aric 就问了一下我们擅长的东西，然后我被分到了韩学长的那个项目，是做一个电磁治疗仪的。 然后下午也没干啥，就在那学了一下午的软件测试，没啥技术活，就是功能测试，点来点去。 后面几天就接着骑车上班，差不多一个星期也熟练了，工作方面的话，项目组负责人 Terry 让我自己选，我选了个线圈拍的部分，主要是做 STM32 的。然后就是对着项目代码猛看了几天，用 PlantUML 工具画了个类图分析，项目组里的东哥和 Terry 都觉得这个不错，算是我推广工具成功了。 周六的时候去了 Bilibili World，感觉还不错，拍了很多照片，也合影了很多 Coser。晚上回来的时候顺道去了可以抽塔菲夏日赏（就一种抽卡活动）的樱动漫店，碰到了氪佬，一下抽了好几千块，是真的牛批。帮室友抽完五发之后就去了外滩，不得不说外滩人是真的多，感觉比 BW 还多了，还有豫园地铁站人也是真的多，大概是我见多的地铁站里之最了。 总的来说，第一周体验良好，基本学会了自行车，也开始进入项目了，还去了 BW 和外滩。","tags":["实习"]},{"title":"断指-电子皮肤开发文档","path":"/2023/07/04/项目/断指-电子皮肤开发文档/","content":"断指-电子皮肤开发文档 系统框架流程 信号读取 使用 ESP 32 的 ADC 外设读取电极输出的电压，截取一段原始电压数据进行打包，并通过 socket 通信向服务器公网 IP 发送。 信号处理 服务器通过 socket 通信接收 ESP 32 发送过来的原始电压数据，对其进行特征值提取，随后即将特征值输入分类模型内对其进行分类，分类结果通过 socket 通信发送到 Flutter 客户端和 ESP 32 设备端。 结果输出 在 Flutter 客户端 APP 通过 socket 通信接收来自服务端的分类结果，并切换对应图片进行直观展示，同时 ESP 32 设备端也会接收来自服务端的结果，并驱动对应舵机带动手指。 系统流程图如下： 开发环境： 设备端：ESP 32 DevkitC-1 开发板 服务端：Microsoft Azure 虚拟机（Ubuntu 系统） 客户端：Flutter 跨平台框架 123456789graph LR电子皮肤 --输出信号--&gt; 设备端设备端 --发送数据--&gt; 服务端设备端 --控制--&gt; 断指辅具服务端 --返回结果--&gt; 设备端服务端 --返回结果--&gt; 客户端 下面将详细介绍各模块设计与实现。 设计与实现 设备端 电子皮肤/断指ESP32程序 该模块使用 PlatformIO 开发，若使用 Arduino IDE 复现或二次开发本模块，将 src 文件夹中的 main.cpp 改为 main.ino 即可编译。 如果安装时，舵机绑线位置不对，可以通过修改舵机初始角度和转动角度在软件层面调整。 程序逻辑图如下： 123456789101112131415graph LRA[开始] --&gt; B(连接WiFi)B --&gt; C&#123;是否连接成功?&#125;C --&gt;|是| D[启动定时器]C --&gt;|否| BD --&gt; E&#123;是否采样完数据?&#125;E --&gt;|是| F[发送数据包]E --&gt;|否| G[采样数据]F --&gt; H&#123;是否收到响应?&#125;H --&gt;|是| I[解析响应]H --&gt;|否| FI --&gt; J&#123;是否需要控制手指舵机?&#125;J --&gt;|是| K[控制手指舵机]J --&gt;|否| EK --&gt; E 服务端 电子皮肤/断指服务端程序 该模块主要分为两个部分： 第一部分是训练模型，主要通过 sklearn 中的随机森林分类器来对 data 文件夹下的数据进行训练，并输出模型到 model 文件夹。 第二部分是部署模型，该部分通过接收设备端的原始数据，通过 server.py 处理并返回模型的输出分类标签到设备端和客户端。 程序逻辑图如下： 123456789101112131415161718192021graph LRA[创建服务器套接字] --&gt; B[绑定到指定端口]B --&gt; C[监听客户端连接]C --&gt; D[等待客户端连接]D --&gt; |ESP32客户端连接请求| E[处理ESP32客户端连接]D --&gt; |Flutter客户端连接请求| F[处理Flutter客户端连接]E --&gt; G[等待ESP32客户端发送数据]G --&gt; H[处理数据并发送预测结果]H --&gt; I&#123;是否有Flutter客户端连接?&#125;I --&gt; |是| J[发送预测结果到所有Flutter客户端]I --&gt; |否| GJ --&gt; K&#123;是否发送成功?&#125;K --&gt; |是| L[继续等待ESP32客户端发送数据]K --&gt; |否| M[从连接列表中移除连接]F --&gt; N[等待Flutter客户端发送数据]N --&gt; O&#123;是否有ESP32客户端连接?&#125;O --&gt; |是| P[处理数据]P --&gt; Q&#123;是否需要发送控制指令?&#125;Q --&gt; |是| R[发送控制指令到ESP32客户端]Q --&gt; |否| NO --&gt; |否| S[从连接列表中移除连接] 客户端 电子皮肤/断指Flutter程序 该模块使用 Flutter 跨平台软件开发框架，不推荐复现本模块，因为环境配置较为繁琐。 程序逻辑图如下： 12345678910111213141516171819202122graph LRA[创建SharedPreferences实例] --&gt; B[读取服务器IP地址和端口号]B --&gt; C[连接服务器]C --&gt; D&#123;是否连接成功?&#125;D --&gt; |是| E[发送身份验证消息]D --&gt; |否| F[显示连接失败提示]E --&gt; F[显示连接成功提示]E --&gt; G[等待服务器数据]G --&gt; H&#123;是否收到数据?&#125;H --&gt; |是| I[解析数据并更新UI]H --&gt; |否| GI --&gt; J[根据数据更新UI]J --&gt; K&#123;是否需要发送控制指令?&#125;K --&gt; |是| L[发送控制指令到服务器]K --&gt; |否| GL --&gt; M&#123;是否发送成功?&#125;M --&gt; |是| GM --&gt; |否| N[显示发送失败提示]F --&gt; O[显示错误]O --&gt; P[关闭连接并重试]N --&gt; PP --&gt; C","tags":["项目"]},{"title":"基于 FOC 驱动谐波减速器的仿 UR 机械臂开发路线图","path":"/2023/06/14/项目/基于 FOC 驱动谐波减速器的仿 UR 机械臂开发路线图/","content":"基于 FOC 驱动谐波减速器的仿 UR 机械臂开发路线图 理论基础 电机原理 了解无刷直流电机（BLDC）的工作原理、结构和性能参数。 底层原理极其简单，却很难造出精品！无刷直流电机的工作原理_哔哩哔哩_bilibili FOC（磁场定向控制）原理 学习 FOC 的基本概念、控制策略和实现方法。 【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术 - 知乎 (zhihu.com) 控制理论 了解控制算法的基本原理，如 PI、PID 控制等。 在 FOC 控制中主要用到三个 PID 环，从内环到外环依次是：电流环、速度环、位置环。 FOC 控制算法 STM32 HAL 库编程 学习如何使用 STM32 进行编程，实现 FOC 控制算法。 数字信号处理 了解数字信号处理的基本概念和方法，如傅里叶变换、滤波器设计等。 传感器技术 学习如何使用电流、电压和位置传感器（如霍尔传感器、编码器等）进行测量和控制。 FOC 驱动器 基础电子元器件 了解电子元件（如电阻、电容、电感、二极管、晶体管等）的性能和使用方法。 常用元器件基础知识详解 - 知乎 (zhihu.com) 电路设计 学习如何设计电路，包括电源管理、信号处理、驱动电路等。 PCB 设计 学习如何使用 PCB 设计软件（如立创 EDA、Altium Designer、KiCad 等）设计和制作电路板。 ROS 正逆运动学 学习如何使用正逆运动学计算机械臂的位姿。 路径规划 使用 ROS 的 MoveIt! 等工具学习机械臂的路径规划，实现机械臂的定位抓取效果。 路线图 【自制】机器人的心脏–超迷你FOC矢量控制驱动器【软核】_哔哩哔哩_bilibili 使用 STM32 HAL 库实现 FOC 闭环控制； 将谐波减速器和电机安装配合在一起进行闭环控制； 学习 FOC 和无刷电机基础理论； 复现稚晖君的 FOC 驱动器效果； 学习正逆运动学基础理论； 在 ROS 中仿真模拟机械臂路径规划； 使用 UR 开源的模型复现机械臂并实现控制路径规划。","tags":["项目"]},{"title":"SPI 通信协议","path":"/2023/05/29/技术/通信协议/SPI/","content":"SPI 施工中…","tags":["嵌入式","通信协议"]},{"title":"不要自己感动自己","path":"/2023/05/29/转载/不要自己感动自己/","content":"这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。 —— 于宙《我们这一代人的困惑》","tags":["转载"]},{"title":"内卷与未来的职业趋势","path":"/2023/05/29/转载/内卷与未来的职业趋势/","content":"经济不景气，更有利于早点去朝阳行业。 早早去站位，早早去占坑。 本科生去了，几年后，就会发现，读研的同学还没有你混的好。 内卷，是无意义的做功。 一群人在无意义的做功，我们只要找到新方向的风口，过去占位。 占位，不卷。等到占稳了位置，就会有人卷过来。 到时候门槛水涨船高，但进入的早，便能卡住位置。 熟悉历史规律，自然能够找到合理的策略。 就像是在历史上，历次大萧条后，都会出现的洗牌。 对普通人来说，这恰恰是珍贵的机会。 —— 「立华说」","tags":["转载"]},{"title":"如何区分 INTJ 和 INTP？","path":"/2023/05/21/转载/如何区分 INTJ 和 INTP？/","content":"如何区分 INTJ 和 INTP？ INTP 和 INTJ 们在人群中很好识别，尤其是典型的 INTJ。作为与 INTJ 和 INTP 均有过（相当）大数量且深度接触的人，你一定能在人群中仅凭短暂的交流识别出一个 INT，尤其是那些特征典型的。在这里，我之所以强调要是特征典型的，是因为人的性格分布像是一个连续的光谱，只有特征足够典型才有好的代表性。想象一条色带从白色渐变到黑色，你难以断定到底哪一处是黑白的分界线，然后指着那条线说，左边的便是白，右边的便是黑。你想要给人展示什么是黑色什么是白色，好的策略是在两端而非靠近中间的地方取色。类似地，今天我们要讨论如何在 INT 中识别 J 和 P，应该拿具有代表性的例子作为典型，而非纠结于 INTJ - INTP 的过渡态，或者其他诸如于 INFP - INTP 的过渡态。 对于那些与 INT 有丰富接触的人来说，INT 是很好识别的，因为他们的特征很明显。INT 们偏好独处（但并不总是排斥与他人在一起）（I），想象力天马行空且思维活跃敏捷（N），不迷恋来自五官的刺激（比如美食和衣服）（N），行动和决定高度基于理性的思考而非情感的驱动（T），对于感兴趣的话题非常健谈，而对于不感兴趣的话题简直是木讷的哑巴。需要注意的是，最后一点是识别出 INT 的重要特征：“非常健谈”体现出 INT 思维敏捷活跃（而不是傻子），仅对感兴趣的话题健谈体现出 INT 对这一话题长期的关注和思考，对不感兴趣的话题木讷体现出他们性格内倾（I）的一面 —— 如果你擅于观察，你会发现不是所有人都是“选择性健谈”且“选择性木讷”的。有些人似乎对所有的话题都表现的很有热情，喜欢掺上一脚，这是典型的好社交（E）的表现；有些人不论对什么话题都不苟言笑，似乎从来没有什么能让他们滔滔不绝地说上五分钟，以至于从不了解这类人的眼里来看他们表现的简直像个自闭症（是 I 但不是 INT）；还有些人一遇到感兴趣的话题便能滔滔不绝，而对不感兴趣的话题则缺乏耐心和关注，既吝于发表自己的看法也无看法可发 —— 因为他们与他人的交流是来自于思考（T）而非社交（E）的推动，因此他们对于自己关注和思考得少的话题没有什么自己的观点可供交流。 更具体的来讲，I 和 T 都是很好观察的，毕竟，一个人是表现得喜欢独处（I）还是群处（E）是一个很基本的社交特征；而在短暂的交谈之后也不难发现一个人是否擅于思考（T/F）—— 如果这个人有自己想法，对事物能发表自己的观点，那多半是 T。 而判断是否是 N 的标准则显得略微含糊，一个好用的方法是排除法：如果一个人鲜现 S 的特征（比如，迷恋于五官的刺激），那大概便是 N 了。INTJ 和 INTP 分享了很多共同的特征，这让很多不够熟悉 INTP 和 INTJ 的人（有时甚至包括他们自己，当然前提是他们知道 MBTI 是什么）容易将这两类人弄混。一个佐证是，一个 INTP 如果去看 INTJ 的介绍，他会发现很多 INTJ 的特征好像自己也有，以至于自己仿佛就是个 INTJ；反之，让一个 INTJ 去看 INTP 的介绍亦然。除此之外，这种“相似性”是排他的：你只会在 INT 里观察到这种 INT 共轭现象，倘若你让一个 INTP 去看 ISFP 或者其他哪类人介绍，多半是不会出现这种迷之幻觉的。另一个类似的佐证是，一个 INTP 如果去一个 INTJ 聚集的地方（比如豆瓣的 INTJ 小组）看看 INTJ 们都在聊些什么，他会发现 INTJ 聊的内容他多半感兴趣，而如果让他去其他什么非 INT 类型的聚集地看，这不会有这种感受，如果他去完全相反的 ESFJ 聚集的地方看，则会对他们所聊的话题完全不感兴趣。这一点对 INTJ 也类似。 验证完了 INT，最难的就是接下来的区分 P 和 J 了。那么，INTP 和 INTJ 到底有哪些表观差别？如果你和他们相处的多了，你会首先发现 INTJ“性格之恶劣”——至少对于典型的 INTJ 是如此。不同于 INTP，INTJ 是极难相处的（想想牛顿，如果你对牛顿的生平经历不熟，想想 Sheldon 和 Sherlock），他们可以轻易摧毁大多数人容忍傻逼的能力。他们往往思维固执，行为习惯与常人不同且不愿改变。举个栗子，如果你曾关注过 INTJ 的 @曾加 ，你一定会发现他的文风甚为“诡异”——几乎总是“列表式回答”。虽然我不得不说，这种组织结构能将主要观点简明扼要、结构清晰地展现出来，但是风格未免过于“自成一派”。如果换做非 INTJ，即使他们发现了这种列表式回答的优势，也多半会弃而不用，向主流的风格妥协。诸如这种表现出来的不合群是大多数人与 INTJ 难以相处的重要原因，也直接导致了 INTJ 的人际关系很差（再次想想牛顿，Sheldon 和 Sherlock）。不过深究起来，这是因为 INTJ 并不在乎他们的人际关系差。他们关注的是“他们认为的”实用的东西，比如，Sherlock 只关注从破案中获得的极大乐趣，他的一切其他行为习惯包括对人际关系的处理都是为这一目的服务的。 除此之外，INTJ 均极度缺乏幽默感，他们大概从来不懂什么是幽默。虽然并不是每个人都有幸接触过典型的 INTJ，但是接触过的人想必对他们缺乏幽默的能力印象深刻。他们不仅无法表达幽默，甚至也无法理解幽默。你能想象 Sheldon 或者 Sherlock 听见笑话后捧腹大笑的样子么？或者，你能想象 Sherlock 和 Watson 走在路上互相取乐互损的样子，就像你和你的闺蜜或者基友那样么？所以啊，和 INTJ 讲笑话或者互相调侃大概是世界上最难堪的事了，他们大概会一本正经的回应你让你尴尬症大犯。注意了，我这里可没有说 INTJ 都不会笑，也没说 INTJ 不会快乐，毕竟，幽默和笑是两回事，和快乐又是两回事。事实上，INTJ 获取乐趣的途径只是和常人有所不同罢了。 相反，INTP 则好相处得多了，这很大一部分是出于他们的随和（想想爱因斯坦不爱穿袜子，甚至不爱在相应的场合穿相应的衣服）。如果说 INTJ 是个强迫症，一定要按照自己的准则来（比如，如果爱因斯坦是 INTJ，他则会坚持要求得体的着装，也多半无法容忍自己办公室的杂乱），那么 INTP 则是虽然自己有很多准则，但是依据情况可以随机应变的那类人。这里要注意了，这种随机应变可不一定就是好事，因为总有你需要坚持自己准则的情况，而这种随机应变便是坚持的绊脚石；当然，随机应变也不一定是坏事，这一点是很显然的。除此之外，如果说 INTJ 是罕见的难相处，那么 INTP 的随和则很大程度上使得 INTP 成为了罕见的能与 INTJ 相处的人。另外一个原因是 INTP 因为在很多方面与 INTJ 相似，所以能够很大程度上理解 INTJ 在他人眼中怪异的行为。总而言之，在常人看来 INTJ 是罕见的“傻逼”，而 INTP 是罕见的如此能容忍“傻逼”的人。在这一点上，Watson 对于 Sherlock 的容忍做得相当不错，可惜，他并不是 INTP。这里并不矛盾，毕竟不是只有 INTP 才会这样随和的，不然，INTP 岂不是太好辨认了，我干嘛还要费这么多口舌？ 那么，为什么我说 Watson 不是 INTP？因为 Watson 不具幽默感。与 INTJ 完全相反，幽默感是 INTP 的一个重要特征（想想爱因斯坦吐舌头的那张照片）。这里我要再次提醒读者注意了，我可没有说有幽默感的就是 INTP，我也没暗示有幽默感就是会讲段子，能互相挖苦取乐，这些都只是判定一个人是 INTP 的必要条件不充分条件。幽默感的内涵是丰富的，它体现在挖掘生活的乐趣的能力。你一定会发现，你身边中有一些人沉闷至极，对许多有趣的事情或者现象完全不甚关心，INTP 则是一群相反的人，他们擅于从生活中发现乐趣。他们并不一定总是会把这种乐趣表现出来，但他们的确是发现了。想想《童趣》里沈复的“忽有庞然大物，拔山倒树而来”，实则“盖一癞虾蟆”，大概就能体会到何为幽默感了。 当然，INTP 和 INTJ 还有很多别的差别，上面说的只是表面上容易观察到的——虽然实际上并不好观察，以至于人们常常弄混。 转载自知乎博主 —— Le Hu","tags":["MBTI","心理学"]},{"title":"链接装载库","path":"/2023/05/20/技术/链接装载库/","content":"链接装载库 一、内存、栈、堆 一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文； 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域； 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里； 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0；（NULL），因此 0 地址正常情况下不可能有效的访问数据。 栈 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： 函数的返回地址和参数； 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量； 保存上下文：包括函数调用前后需要保持不变的寄存器。 堆 堆分配算法： 空闲链表（Free List）； 位图（Bitmap）； 对象池。 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write” 典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针； 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针。 编译链接 各平台文件格式 平台 可执行文件 目标文件 动态库/共享对象 静态库 Windows exe obj dll lib Unix/Linux ELF、out o so a Mac Mach-O o dylib、tbd、framework a、framework 编译链接过程 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件）； 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件）； 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件）； 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件）。 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld。 MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin。 目标文件 编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）。 目标文件格式 Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式； Linux 的 ELF（Executable Linkable Format），.o 格式； Intel/Microsoft 的 OMF（Object Module Format）； Unix 的 a.out 格式； MS-DOS 的 .COM 格式。 PE 和 ELF 都是 COFF（Common File Format）的变种。 目标文件存储结构 段 功能 File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） .text section 代码段，执行语句编译成的机器代码 .data section 数据段，已初始化的全局变量和局部静态变量 .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 .comment section 注释信息段，存放编译器版本信息 .note. GNU-stack section 堆栈提示段 链接的接口 —— 符号 在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。 如下符号表（Symbol Table）： Symbol（符号） Symbol Value（地址） main 0x100 Add 0x123 … … Linux 的共享库（Shared Library） Linux 下的共享库就是普通的 ELF 共享对象。 共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容 命名 libname. So. X. Y. Z X：主版本号，不同主版本号的库之间不兼容，需要重新编译； Y：次版本号，高版本号向后兼容低版本号； Z：发布版本号，不对接口进行更改，完全兼容。 路径 大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。 /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等； /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库； /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库。 动态链接器会在 /lib、/usr/lib 和由 /etc/ld. So. Conf 配置文件指定的，目录中查找共享库。 环境变量 LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序； LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件； LD_DEBUG：打开动态链接器的调试功能。 So 共享库的编写 使用 VS Code 编写共享库，创建一个名为 MySharedLib 的共享库： CMakeLists. Txt： 1234Cmake_minimum_required (VERSION 3.10)Project (MySharedLib)Set (CMAKE_CXX_STANDARD 11)Add_library (MySharedLib SHARED library. Cpp library. H) Library. H： 12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!Void hello ();// 使用可变模版参数求和template &lt;typename T&gt;T sum (T t)&#123; Return t;&#125;template &lt;typename T, typename... Types&gt;T sum (T first, Types... Rest)&#123; return first + sum&lt;T&gt;(rest...);&#125;#endif Library. Cpp： 1234567#include &lt;iostream&gt;#include &quot;library. H&quot;Void hello ()&#123; Std:: cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std:: endl;&#125; So 共享库的使用 使用 VS Code 调用共享库，创建一个名为 TestSharedLib 的可执行项目： CMakeLists. Txt： 1234567891011121314151617181920Cmake_minimum_required (VERSION 3.10)Project (TestSharedLib)# C++11 编译Set (CMAKE_CXX_STANDARD 11)# 头文件路径Set (INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径Set (LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)Include_directories ($&#123;INC_DIR&#125;)Link_directories ($&#123;LIB_DIR&#125;)Link_libraries (MySharedLib)Add_executable (TestSharedLib main. Cpp)# 链接 MySharedLib 库Target_link_libraries (TestSharedLib MySharedLib) Main. Cpp： 1234567891011121314#include &lt;iostream&gt;#include &quot;library. H&quot;Using std:: cout;Using std:: endl;Int main ()&#123; Hello (); Cout &lt;&lt; &quot;1 + 2 = &quot; &lt;&lt; sum (1, 2) &lt;&lt; endl; Cout &lt;&lt; &quot;1 + 2 + 3 = &quot; &lt;&lt; sum (1, 2, 3) &lt;&lt; endl; Return 0;&#125; 执行结果： 123Hello, World!1 + 2 = 31 + 2 + 3 = 6 Windows 应用程序入口函数 GUI（Graphical User Interface）应用，链接器选项：/SUBSYSTEM:WINDOWS CUI（Console User Interface）应用，链接器选项：/SUBSYSTEM:CONSOLE _tWinMain 与 _tmain 函数声明： 12345678910Int WINAPI _tWinMain ( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, Int nCmdShow);Int _tmain ( Int argc, TCHAR *argv[], TCHAR *envp[]); 应用程序类型 入口点函数 嵌入可执行文件的启动函数 处理 ANSI 字符（串）的 GUI 应用程序 _tWinMain (WinMain) WinMainCRTSartup 处理 Unicode 字符（串）的 GUI 应用程序 _tWinMain (wWinMain) wWinMainCRTSartup 处理 ANSI 字符（串）的 CUI 应用程序 _tmain (Main) mainCRTSartup 处理 Unicode 字符（串）的 CUI 应用程序 _tmain (wMain) wmainCRTSartup 动态链接库（Dynamic-Link Library） DllMain _DllMainCRTStartup Windows 的动态链接库（Dynamic-Link Library） 用处 扩展了应用程序的特性； 简化了项目管理； 有助于节省内存； 促进了资源的共享； 促进了本地化； 有助于解决平台间的差异； 可以用于特殊目的。 注意 创建 DLL，事实上是在创建可供一个可执行模块调用的函数； 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）； 在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符； 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）； DLL 模块：cpp 文件中的 __declspec (dllexport) 写在 include 头文件之前； 调用 DLL 的可执行模块：cpp 文件的 __declspec (dllimport) 之前不应该定义 MYLIBAPI。 加载 Windows 程序的搜索顺序 包含可执行文件的目录； Windows 的系统目录，可以通过 GetSystemDirectory 得到； 16 位的系统目录，即 Windows 目录中的 System 子目录； Windows 目录，可以通过 GetWindowsDirectory 得到； 进程的当前目录； PATH 环境变量中所列出的目录。 DLL 入口函数 DllMain 函数： 123456789101112131415161718192021222324252627BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; Switch (fdwReason) &#123; Case DLL_PROCESS_ATTACH: // 第一次将一个 DLL 映射到进程地址空间时调用 // The DLL is being mapped into the process&#x27; address space. Break; Case DLL_THREAD_ATTACH: // 当进程创建一个线程的时候，用于告诉 DLL 执行与线程相关的初始化（非主线程执行） // A thread is bing created. Break; Case DLL_THREAD_DETACH: // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉 DLL 执行与线程相关的清理 // A thread is exiting cleanly. Break; Case DLL_PROCESS_DETACH: // 将一个 DLL 从进程的地址空间时调用 // The DLL is being unmapped from the process&#x27; address space. Break; &#125; Return (TRUE); // Used only for DLL_PROCESS_ATTACH&#125; 载入卸载库 12345678910111213141516171819202122// 载入库HMODULE WINAPI LoadLibrary ( _In_ LPCTSTR lpFileName);HMODULE LoadLibraryExA ( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryExHMODULE LoadPackagedLibrary ( LPCWSTR lpwLibFileName, DWORD Reserved);// 卸载库BOOL WINAPI FreeLibrary ( _In_ HMODULE hModule);// 卸载库和退出线程VOID WINAPI FreeLibraryAndExitThread ( _In_ HMODULE hModule, _In_ DWORD dwExitCode); 显示地链接到导出符号 GetProcAddress 函数声明： 1234FARPROC GetProcAddress ( HMODULE hInstDll, PCSTR pszSymbolName // 只能接受 ANSI 字符串，不能是 Unicode); DumpBin. Exe 查看 DLL 信息 在 VS 的开发人员命令提示符 使用 DumpBin. Exe 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如： 1DUMPBIN -exports D:\\mydll. Dll DLL 库的编写（导出一个 DLL 模块） DLL 库的编写（导出一个 DLL 模块） DLL 头文件： 1234567891011121314151617// MyLib. H#ifdef MYLIBAPI// MYLIBAPI 应该在全部 DLL 源文件的 include &quot;Mylib. H&quot; 之前被定义// 全部函数/变量正在被导出#else// 这个头文件被一个 exe 源代码模块包含，意味着全部函数/变量被导入#define MYLIBAPI extern &quot;C&quot; __declspec (dllimport)#endif// 这里定义任何的数据结构和符号// 定义导出的变量（避免导出变量）MYLIBAPI int g_nResult;// 定义导出函数原型MYLIBAPI int Add (int nLeft, int nRight); DLL 源文件： 123456789101112131415161718// MyLibFile1. Cpp// 包含标准 Windows 和 C 运行时头文件#include &lt;windows.h&gt;// DLL 源码文件导出的函数和变量#define MYLIBAPI extern &quot;C&quot; __declspec (dllexport)// 包含导出的数据结构、符号、函数、变量#include &quot;MyLib. H&quot;// 将此 DLL 源代码文件的代码放在此处Int g_nResult;Int Add (int nLeft, int nRight)&#123; G_nResult = nLeft + nRight; Return g_nResult;&#125; DLL 库的使用（运行时动态链接 DLL） DLL 库的使用（运行时动态链接 DLL）： 1234567891011121314151617181920212223242526272829303132333435363738// A simple program that uses LoadLibrary and// GetProcAddress to access myPuts from Myputs. Dll.#include &lt;windows.h&gt;#include &lt;stdio.h&gt;Typedef int (__cdecl *MYPROC)(LPWSTR);Int main (void)&#123; HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module. HinstLib = LoadLibrary (TEXT (&quot;MyPuts. Dll&quot;)); // If the handle is valid, try to get the function address. If (hinstLib != NULL) &#123; ProcAdd = (MYPROC) GetProcAddress (hinstLib, &quot;myPuts&quot;); // If the function address is valid, call the function. If (NULL != ProcAdd) &#123; FRunTimeLinkSuccess = TRUE; (ProcAdd)(L&quot;Message sent to the DLL function &quot;); &#125; // Free the DLL module. FFreeResult = FreeLibrary (hinstLib); &#125; // If unable to call the DLL function, use an alternative. If (! FRunTimeLinkSuccess) Printf (&quot;Message printed from executable &quot;); Return 0;&#125; 运行库（Runtime Library） 典型程序运行步骤 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）； 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）； 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分； Main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭 I/O 等），然后进行系统调用结束进程。 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。 Glibc 入口 _start -&gt; __libc_start_main -&gt; exit -&gt; _exit 其中 main (argc, argv, __environ) 函数在 __libc_start_main 里执行。 MSVC CRT 入口 int mainCRTStartup (void) 执行如下操作： 初始化和 OS 版本有关的全局变量； 初始化堆； 初始化 I/O； 获取命令行参数和环境变量； 初始化 C 库的一些数据； 调用 main 并记录返回值； 检查错误并将 main 的返回值返回。 C 语言运行库（CRT） 大致包含如下功能： 启动与退出：包括入口函数及入口函数所依赖的其他函数等； 标准函数：有 C 语言标准规定的 C 语言标准库所拥有的函数实现； I/O：I/O 功能的封装和实现； 堆：堆的封装和实现； 语言实现：语言中一些特殊功能的实现； 调试：实现调试功能的代码。 C 语言标准库（ANSI C） 包含： 标准输入输出（stdio. H）； 文件操作（stdio. H）； 字符操作（ctype. H）； 字符串操作（string. H）； 数学函数（math. H）； 资源管理（stdlib. H）； 格式转换（stdlib. H）； 时间/日期（time. H）； 断言（assert. H）； 各种类型上的常数（limits. H &amp; float. H）； 变长参数（stdarg. H）； 非局部跳转（setjmp. H）。","tags":["计算机"]},{"title":"B 站视频评论精选","path":"/2023/05/19/转载/转载/","content":"给可能还在高中的孩子们写点我自己的心得 不要对你的大学生活抱有一丝幻想 刚被我亲爱的末流酒吧舞录取的时候全家欢天喜地，我也跟着在欢喜中沉浸了一下。进了学校我傻了，我是来干啥的？来开班会的？来上晚自习的？来早上五点参加升旗的？来开 zz 理论学习课的？来看青年带学习的？来元旦越野跑的？来乐跑的？来配合学院导员做政绩参加无尽的活动的？一天不光要上一堆课还有各种各样五彩斑斓花样繁多的屁事。周末要是没有破事我真的谢天谢地。真正感受下来比高三累多了（应该是因为高中比较混）高中的累是为自己的未来而累，大学的累是那种接受劳动改造的累，不好好接受改造就给你加刑。 课表里的课更是一门比一门怪。是那种既晦涩又没用的怪。期末要是论文考核那真的是触目惊心啊，你抄我我抄你，含金量未必有 AI 写的高。记得有一门课就十五个课时，要学 4 个软件还要出一个作品。我同学的一个课设完全是代练包办的。我看了他的课设效果秒杀任何自己做的同学，老师教的没教的他都做了，完全就是商单的水准。我以为他的作业会被老师一眼识破然后死的很惨，结果老师好像真的以为他教得很好，给他打了个 92 分过了。实在给我整笑了。最惨的是一个四款软件都安装不上的同学，只能借别人的电脑做。效果不好被挂了。 上了大二，高中时的一个学妹问我大物题，我不会，问年级前 10%的室友，他也忘了。我苦笑着问他咱俩是来干啥的。直到前段时间，看了部美剧叫《Tulsa King》史泰龙在里面说了句话，大概意思是“所有人都在吐槽本科文凭不值钱了，但其实本科文凭的意义已经不在于证明你你受过什么教育，而是向用人单位证明你能在四年时间里按时完成一系列的任务，不管这个任务有没有意义。” 看完之后我就释然了。我以为我是来证明自己属于前 10%的。结果我是来证明自己是个合格的工作机器的？不差钱，开混。 总而言之，不论你进入大学的初心是怎样的，准备好迎接自己人生中最滑稽最荒诞的四年吧。经历了这四年，职场可能真的没那么可怕了，起码人家给钱。 转载自 B 站某用户"},{"title":"我为什么选择不考研？","path":"/2023/05/19/思考/我为什么选择不考研？/","content":"我为什么选择不考研？ 序 最近很多大三同学已经开始准备考研了，其实从去年下半年（也就是大三上学期）就逐渐有人开始准备考研了，我的父母也希望我能够考研去读硕士研究生，但其实我并不想考研去读硕士研究生 主观因素 对科研不感兴趣 对学校不感兴趣 客观因素 考研是加杠杆的投资行为 “考研是加杠杆的投资行为” 这句话可以理解为，通过参加研究生入学考试（考研）并成功获得研究生资格，是对自己未来的一种投资。这里的&quot;加杠杆&quot;表示这种投资可以放大个人的收益和影响力。 具体来说，投资自己的教育和发展是一种长期的行为。通过考研，你可以在专业领域深造，提高自己的技能和知识水平，从而在职场上获得更好的发展机会和提高收入。这种收益是具有杠杆效应的，因为你所投入的时间、精力和金钱可能会带来比直接进入职场更大的回报。此外，研究生学历在社会中的认可度较高，有助于提升个人的社会地位和影响力。 因此，将考研看作一种加杠杆的投资行为，意味着通过这种投资，你有望在未来获得更高的回报和成就。当然，这种投资的风险也不可忽视，考研过程中可能遇到的挑战和竞争压力较大，需要付出较大的努力才能成功。 考研形式与就业形式 总结","tags":["考研"]},{"title":"Fountain 语法手册","path":"/2023/05/16/技术/Fountain 语法手册/","content":"Fountain 语法手册 Fountain 是一种简单的文本格式，用于编写电影剧本和电视剧本。它的设计目的是让作者能够使用任何文本编辑器轻松撰写剧本，同时保持兼容性，方便将剧本导入专业剧本软件进行处理。以下是一些基本的 Fountain 语法规则： 一、标题（Title Page） Fountain 支持在剧本开头添加标题页，包括标题（Title）、作者（Author）、联系信息（Contact）、版权信息（Copyright）等。标题页信息用 : 分隔标签和内容。例如： 1234Title: 我的电影剧本Author: 张三Contact: zhangsan@example.comCopyright: © 2023 张三 二、场景标题（Scene Headings） 场景标题通常以大写字母开头，表示场景的位置，后跟一个破折号。Fountain 支持如下三种场景标题： INT.（内景） EXT.（外景） I/E.（内外景） 例如： 1EXT. 时代广场 - 夜晚 三、角色（Character）和对白（Dialogue） 角色名用大写字母表示，位于对话之上。角色名与对话间用空行隔开。例如： 12JOHN我爱这个城市。 四、过渡（Transitions） 过渡表示场景之间的转换方式，如：CUT TO:、FADE IN:、FADE OUT:。过渡通常位于行首，右对齐，后跟一个冒号。例如： 1CUT TO: 五、动作（Action） 动作是描述场景中发生的事情。动作行应位于场景标题、角色和对白之间。例如： 1角色走到窗前，凝视着外面的风景。 六、插入备注（Parentheticals） 插入备注用于描述角色的动作或表情，它位于角色名和对白之间，用括号括起来。例如： 123SARAH(犹豫地)我不确定这是个好主意。 七、双栏（Dual Dialogue） 当两个角色同时说话时，可以使用双栏。在角色名后添加 ^ 符号表示该角色与下一个角色的对话是同时进行的。例如： 12345JOHN^你觉得怎么样？SARAH^我很喜欢这里！","tags":["GalGame","剧本"]},{"title":"Think Different","path":"/2023/05/12/人文/子/Think Different/","content":"前言 “Larry 想做技术大佬”是一位 B 站 UP 主，从第一个视频开始就开始针对社会出现的盲目“考研”行为进行了抨击，并且针对大学生群体给出了许多建议：比如做 UP 主，","tags":["思考"]},{"title":"NASA 写给修女的一封回信","path":"/2023/05/10/人文/子/NASA 写给修女的一封回信/","content":"我们为何要仰望星空，花费大量的金钱和精力探索那不可预知的宇宙呢？NASA 科学家写给非洲修女的一封信回答得特别好，也特别震撼人心。——这不禁让我想起之前阅读过的一封圣诞老人是否存在的答复信，其实这个世界，有的时候需要的只是一个解释，足以告慰人心的解释。 序 1970 年，赞比亚（非洲一个兵荒马乱的穷苦国家）的一名修女玛丽·尤肯达写信给 NASA，善良的修女无法理解，地球上还有很多孩子需要忍受饥饿煎熬，为什么美国还要耗费数十亿美元尝试把人送到宇宙里去？ NASA的一名科学家恩斯特·史都林格给她回信，全文如下： 中文译版 尊敬的玛丽·尤肯达修女： 你的来信收到了。我每天都会收到很多信，这一封对我的触动最大，因为它让我看到了一个富有探求精神的灵魂，一颗仁慈怜悯之心。我会尽我所能回答你提出的问题。首先，我要向你以及和你一样的勇敢修女们表达深深的敬意，因为你们将毕生精力献身于人类最高尚的事业 —— 帮助所有需要帮助的人。 你在信中问我，为何我会在地球上仍有很多儿童面临饿死威胁之时，建议投入数十亿美元实施火星探索计划？我想你一定不希望我给出这样一种回答 —— “哦，我并不知道很多孩子正因为饥饿走向死亡，从这一刻起，我会停止任何太空方面的研究，直到人类解决这个问题。”实际上，在我意识到火星之旅在技术上具有可行性前很久，我就已经知道很多孩子正在挨饿。然而，我以及我的很多同伴仍然坚信前往月球、火星以及其他行星是一种在当下值得进行的冒险，我甚至认为这项探索计划与其他很多潜在的援助计划相比，能够在更大程度上帮助解决我们面临的各种严峻问题。援助计划每年都在讨论和争论，但所产生的效果却远远没有达到令人满意的程度。 在解释太空探索计划如何帮助我们解决地球上的各种问题之前，我想先给你讲一个真实的故事，这个故事也许有助于你了解我的观点。故事发生在大约 400 年前德国的一个小镇。这个小镇有一位非常仁慈的伯爵，把自己的大部分收入都用来救济镇上的穷苦百姓。这份仁慈令人非常感动，因为在中世纪，穷苦百姓实在是太多了并且经常出现全国性瘟疫。 有一天，伯爵遇到一个奇怪的男人。他的家里有一个工作台和一个小实验室。他白天辛勤劳作，每天晚上都会拿出几个小时在自己的实验室搞研究。他将一块块玻璃打磨成小镜片，而后将镜片安装到镜筒上，利用这种装置观察非常微小的物体。放大数倍的微小生灵尤其让伯爵感动不可思议，深深着迷，因为这是他此前从没有见过的。伯爵邀请这名男子带着他的实验设备搬到自己的城堡，成为他的一名“特殊员工”。从此，这个怪人将自己的全部精力都用来研制和改进他的光学仪器上。 镇上的人认为这个怪人是在研究一些没用的东西，伯爵在他身上浪费了太多钱，都感到很愤怒。他们抱怨说：“我们还在忍受瘟疫的折磨，而他却拿钱让这个男人搞一些没有用的爱好。”听到这样的抱怨，伯爵并没有因此动摇，仍坚持自己的做法。他说：“我会尽我所能帮助你们，但我仍会支持他的研究，因为我坚信他的研究终有一天会得到回报。” 事实证明，伯爵的话是对的。这个怪人最后研制出我们现在熟知的显微镜。在促进医学进步方面，其他任何发明都无法与显微镜相提并论。它的问世帮助人类消除世界上大部分地区的瘟疫以及其他很多种接触性传染病。如果没有显微镜，人类无法取得这些成就。在显微镜诞生过程中，伯爵投入的钱显然发挥了重要作用。在帮助减轻人类遭受的苦难方面，花钱支持研制显微镜所能做出的贡献显然远远超过单纯地救济遭受瘟疫侵袭的不幸者。 从很大程度上说，我们面临着类似的情况。美国每年的年度预算大约在 2000 亿美元左右，这笔预算最终花在医疗、教育、福利、城市建设、高速公路、交通运输、外国援助、国防、环境保护、科学研究、农业以及美国国内和国外的很多机构上。今年的预算有大约 1.6% 划拨给太空探索计划。太空探索计划包括阿波罗登月计划，很多涉及到天体物理学、空间天文学和空间生物学的小规模计划，行星探索计划以及与地球资源和太空工程学有关的计划。为了实施这些探索计划，每个年收入1万美元的美国纳税人每年需拿出 30 美元，余下的 9970 美元用于各种生活开支、休闲娱乐、储蓄、其他花销以及其他税赋。 你也许会问：“为什么不从每个美国纳税人缴纳的 30 ‘太空美元’中拨出 5 美元、3 美元或者 1 美元，援助忍受饥饿的儿童呢？”为了回答这个问题，我必须向你简要解释一下美国的国库如何运作。美国的情况与其他国家类似。美国政府由很多部门和机构构成，例如内政部、司法部、卫生教育与福利部、交通部、国防部、国家科学基金会、国家航空航天局（宇航局）。所有这些部门和机构都要根据自身承担的任务制定年度预算，每一笔预算都要受到国会委员会的严格监管，都要承受来自预算局和总统的压力。国会划拨后，各部门和机构的预算只能用于预算案上列出和政府批准的项目。 宇航局的预算只能用于与航空航天有关的探索计划。如果国会没有批准这笔预算，宇航局便无法从其他渠道获得所需的资金。他们不可能直接从纳税人那里筹集资金，唯一的方式就是其他预算提出追加请求并获得批准，宇航局方可获得这笔并非用于太空计划的资金。听完我的介绍，你应该已经意识到援助遭遇饥荒的儿童，或者美国的其他对外援助项目都必须递交用于这些项目的预算请求，经国会批准后方可拿到资金。 你如果问我，我个人是否赞同政府采取援助措施，我的答案无疑是“赞同”。我完全不介意每年多交一些税，用于帮助忍受饥饿煎熬的孩子，不管他们身处何地。我相信我的所有朋友也是相同的态度。不过，我们不会为了实施这样的援助项目而停止火星探索计划。我甚至认为通过实施太空探索计划，我们能够为解决地球上的饥荒和贫困等严峻问题做出更大贡献，最终帮助找到这些问题的解决方案。 解决饥荒问题首先要着眼于两件事情，一个是粮食生产，一个是粮食分配。在世界上的一些地区，农业种植、畜牧业、海洋捕捞以及其他大规模食品生产活动都拥有很高的效率，但其他很多地区的效率都很低。如果在流域治理、肥料使用、天气预报、土壤肥力评估、作物种植规划、农田选择、种植方式、耕种时机选择、作物调查以及收割计划等方面，采取更为有效的技术和举措，我们便可大幅提高粮食产量，进而帮助解决饥荒问题。 毫无疑问，改进粮食生产的最理想工具就是人造地球卫星。人造卫星在高空环绕地球飞行，能够在很短的时间内对面积巨大的陆地区域进行研究，观测大量能够揭示农作物、土壤、干旱、降雨、积雪情况的因素，而后将数据传给地面站。据估计，即使一颗最为简单的地球卫星也能为一项改进全球农业生产的计划做出不小贡献，让作物的年产量大幅提高，带来数十亿美元的收入增长。 与粮食生产相比，将粮食分发给贫困地区是一个完全不同的问题，这个问题不仅涉及到交通运输，同时也涉及到国际合作。在接受大国提供的大批粮食援助时，小国的领导人可能产生担忧情绪，担心大国在提供援助的同时也对外输出了他们的影响力。在我看来，在减少国与国之间的隔阂前，我们不可能实现有效的粮食援助计划。同时，我也不认为太空探索计划能够在一夜时间取得这一成就。不过，太空探索计划却是最有效的方式之一，帮助解决这个问题。 还记得当年死里逃生的“阿波罗 13 号”飞船吗？在“阿波罗 13 号”即将重返地球大气层时，苏联关闭了境内所有与阿波罗计划频带相同的无线电通讯，以防止出现任何可能的干扰，同时派遣船只前往太平洋和大西洋海域，必要的时候执行紧急救援行动。如果搭载宇航员的返回舱在一艘苏联船只附近溅落，苏联人一定会像对待本国宇航员一样，对他们提供帮助。如果苏联宇航员也遇到类似的紧急情况，美国人也会出手相助，这一点毋庸置疑。 通过卫星监测和评估提高粮食产量，通过改善国际关系改进粮食分配，这还只是太空探索计划如何对人类生活产生深远影响的两个例证罢了。除此之外还有两个具有代表性的例证——促进技术进步和提高一代人的科学素养。登月飞船需要拥有极高的精确性和可靠性，在工程学发展史上，登月计划在这两方面取得的成就都是空前的。为满足这些要求，科学家研发了相关系统，这些系统为我们研发新材料和新技术提供了一个前所未有的机会，允许我们发明出更出色的技术系统和制造工艺，延长科学仪器的寿命，发现此前未知的自然定律。 实施阿波罗登月计划过程中掌握的科学知识同样也可用于研发在地球上使用的技术。太空探索计划每年孕育出大约 1000 项技术革新。这些技术革新大幅提高了人类的生活质量，帮助我们研制出性能更卓越的厨房设备、农场设备、缝纫机、无线电设备、船舶、飞机、天气预报和风暴预警系统、通讯设备、医疗设备以及其他日常生活用品。你可能会问，我们为何首先为登月宇航员研发生命支持系统，而后才为心脏病患者研制远程体征监测设备？答案很简单。在解决技术难题过程中取得的重大进步往往不是通过一种直接的方式，而是首先设定一个具有高度挑战性的目标，通过激发强大的动力促进技术革新，点燃科学家的想象力，促使他们尽自己最大可能完成设定的目标。这种方式就像是一个催化剂，催化出连锁反应。 太空飞行无疑扮演着这样的角色。火星之旅虽然不能直接帮助解决饥荒问题，但这项探索计划孕育出的很多新技术和新方法所能给人类带来的益处将远远超过所付出的成本。如果我们希望改善人类的生活质量，我们就需要研发各种新技术，需要继续进行科学研究，了解和掌握我们尚未获得的知识。我们需要进一步研究物理学、化学、生物学和生理学，需要在医药研究的道路上继续前进，战胜各种威胁人类生存的挑战，例如饥荒、疾病、食品和水污染以及环境污染。 我们需要更多的年轻人将科学研究作为毕生的事业。我们需要为科学家提供各种帮助，让他们充分发挥自己的聪明才智，在研究过程中取得丰硕成果。我们必须设定富有挑战性的研究目标并为研究计划提供充分支持。太空探索计划涉及到一系列引人注目的研究，例如对卫星和行星进行研究，对高深的物理学和天文学以及生物学和医学进行研究。它就像是一个完美的催化剂，能够在极大程度上促进科技进步。通过实施太空探索计划，我们得以拥有一系列令人兴奋的机会，观察神秘莫测的自然现象，研发各种新技术和新材料。 在美国政府指导、监管和提供资金的所有活动中，太空探索无疑是最引人注目同时也最能引起讨论的活动，虽然它的预算只占美国总预算的 1.6%，GDP 的 3‰。太空探索是孕育新技术和促进基础科学研究的催化剂，所能起到的作用是其他任何活动无法比拟的。从某种程度上说，太空探索对人类社会产生的深远影响甚至超过几千年来的战争。如果国与国之间不再进行研制轰炸机、火箭等武器的军备竞赛，而是在太空探索领域展开竞争，人类便可免遭很多苦难。这种竞争能够孕育出各种令人兴奋的成就，失败者也不必遭受痛苦命运，更不会制造仇恨和新的战争。 我们实施的太空探索计划虽然让我们远离地球，将目光投向月球、太阳、其他行星和恒星，但太空科学家最关注的仍旧是我们的地球，而不是这些天体。太空探索的终极目标是建设更完美的人类家园，探索过程中获得的所有科学知识以及所研发的所有新技术都将用于改善人类的生活质量。 随信寄出的照片是 1968 年圣诞节期间由“阿波罗 8 号”宇航员在环绕月球飞行时拍摄的，展示了我们的地球家园。在太空探索计划迄今为止取得的众多成就中，这幅照片可能最具有象征意义。它让我们意识到地球是怎样一颗美丽的星球。如果将无边无际的宇宙比作一个海洋，地球就是这个海洋中最美丽最宝贵的一座岛屿，是我们唯一的家园。在此之前，很多人并没有意识到地球的美丽与脆弱，更没有意识到肆意破坏生态平衡将给地球带来怎样的危害。在这幅照片第一次对外公布之后，号召人们警惕人类面临的各种严峻问题和挑战的呼声越来越高，例如污染、饥荒、贫困、城市生活、粮食生产、水资源管理和人口过度增长。拍摄这幅照片时，人类刚刚进步太空时代，也是第一次从太空观察我们的星球。公众对上述问题关注度的提高显然与太空探索计划有关，而非一种偶然。 太空探索为人类提供了一面审视自己的镜子，同时也孕育出一系列新技术。太空探索取得的成就增强了人类的信心和进取精神，让人类相信自己有能力解决面临的各种严峻考验和挑战。在我看来，人类通过太空探索取得的成就充分印证了“非洲圣人”阿尔贝特·施韦泽的那句名言 —— “我忧心忡忡地看待未来，但仍满怀美好的希望。” 献上我最真挚的祝福，永远祝福你和你的孩子们。 您诚挚的， 恩斯特·史都林格 1970 年 5 月 6 日 英文原版 Dear Sister Mary Jucunda: Your letter was one of many which are reaching me every day, but it has touched me more deeply than all the others because it came so much from the depths of a searching mind and a compassionate heart. I will try to answer your question as best as I possibly can. First, however, I would like to express my great admiration for you, and for all your many brave sisters, because you are dedicating your lives to the noblest cause of man: help for his fellowmen who are in need. You asked in your letter how I could suggest the expenditures of billions of dollars for a voyage to Mars, at a time when many children on this Earth are starving to death. I know that you do not expect an answer such as “Oh, I did not know that there are children dying from hunger, but from now on I will desist from any kind of space research until mankind has solved that problem!” In fact, I have known of famined children long before I knew that a voyage to the planet Mars is technically feasible. However, I believe, like many of my friends, that travelling to the Moon and eventually to Mars and to other planets is a venture which we should undertake now, and I even believe that this project, in the long run, will contribute more to the solution of these grave problems we are facing here on Earth than many other potential projects of help which are debated and discussed year after year, and which are so extremely slow in yielding tangible results. Before trying to describe in more detail how our space program is contributing to the solution of our Earthly problems, I would like to relate briefly a supposedly true story, which may help support the argument. About 400 years ago, there lived a count in a small town in Germany. He was one of the benign counts, and he gave a large part of his income to the poor in his town. This was much appreciated, because poverty was abundant during medieval times, and there were epidemics of the plague which ravaged the country frequently. One day, the count met a strange man. He had a workbench and little laboratory in his house, and he labored hard during the daytime so that he could afford a few hours every evening to work in his laboratory. He ground small lenses from pieces of glass; he mounted the lenses in tubes, and he used these gadgets to look at very small objects. The count was particularly fascinated by the tiny creatures that could be observed with the strong magnification, and which he had never seen before. He invited the man to move with his laboratory to the castle, to become a member of the count’s household, and to devote henceforth all his time to the development and perfection of his optical gadgets as a special employee of the count. The townspeople, however, became angry when they realized that the count was wasting his money, as they thought, on a stunt without purpose. “We are suffering from this plague,” they said, “while he is paying that man for a useless hobby!” But the count remained firm. “I give you as much as I can afford,” he said, “but I will also support this man and his work, because I know that someday something will come out of it!” Indeed, something very good came out of this work, and also out of similar work done by others at other places: the microscope. It is well known that the microscope has contributed more than any other invention to the progress of medicine, and that the elimination of the plague and many other contagious diseases from most parts of the world is largely a result of studies which the microscope made possible. The count, by retaining some of his spending money for research and discovery, contributed far more to the relief of human suffering than he could have contributed by giving all he could possibly spare to his plague-ridden community. The situation which we are facing today is similar in many respects. The President of the United States is spending about 200 billion dollars in his yearly budget. This money goes to health, education, welfare, urban renewal, highways, transportation, foreign aid, defense, conservation, science, agriculture and many installations inside and outside the country. About 1.6 percent of this national budget was allocated to space exploration this year. The space program includes Project Apollo, and many other smaller projects in space physics, space astronomy, space biology, planetary projects, Earth resources projects, and space engineering. To make this expenditure for the space program possible, the average American taxpayer with 10,000 dollars income per year is paying about 30 tax dollars for space. The rest of his income, 9,970 dollars, remains for his subsistence, his recreation, his savings, his other taxes, and all his other expenditures. You will probably ask now: “Why don’t you take 5 or 3 or 1 dollar out of the 30 space dollars which the average American taxpayer is paying, and send these dollars to the hungry children?” To answer this question, I have to explain briefly how the economy of this country works. The situation is very similar in other countries. The government consists of a number of departments (Interior, Justice, Health, Education and Welfare, Transportation, Defense, and others) and the bureaus (National Science Foundation, National Aeronautics and Space Administration, and others). All of them prepare their yearly budgets according to their assigned missions, and each of them must defend its budget against extremely severe screening by congressional committees, and against heavy pressure for economy from the Bureau of the Budget and the President. When the funds are finally appropriated by Congress, they can be spent only for the line items specified and approved in the budget. The budget of the National Aeronautics and Space Administration, naturally, can contain only items directly related to aeronautics and space. If this budget were not approved by Congress, the funds proposed for it would not be available for something else; they would simply not be levied from the taxpayer, unless one of the other budgets had obtained approval for a specific increase which would then absorb the funds not spent for space. You realize from this brief discourse that support for hungry children, or rather a support in addition to what the United States is already contributing to this very worthy cause in the form of foreign aid, can be obtained only if the appropriate department submits a budget line item for this purpose, and if this line item is then approved by Congress. You may ask now whether I personally would be in favor of such a move by our government. My answer is an emphatic yes. Indeed, I would not mind at all if my annual taxes were increased by a number of dollars for the purpose of feeding hungry children, wherever they may live. I know that all of my friends feel the same way. However, we could not bring such a program to life merely by desisting from making plans for voyages to Mars. On the contrary, I even believe that by working for the space program I can make some contribution to the relief and eventual solution of such grave problems as poverty and hunger on Earth. Basic to the hunger problem are two functions: the production of food and the distribution of food. Food production by agriculture, cattle ranching, ocean fishing and other large-scale operations is efficient in some parts of the world, but drastically deficient in many others. For example, large areas of land could be utilized far better if efficient methods of watershed control, fertilizer use, weather forecasting, fertility assessment, plantation programming, field selection, planting habits, timing of cultivation, crop survey and harvest planning were applied. The best tool for the improvement of all these functions, undoubtedly, is the artificial Earth satellite. Circling the globe at a high altitude, it can screen wide areas of land within a short time; it can observe and measure a large variety of factors indicating the status and condition of crops, soil, droughts, rainfall, snow cover, etc., and it can radio this information to ground stations for appropriate use. It has been estimated that even a modest system of Earth satellites equipped with Earth resources, sensors, working within a program for worldwide agricultural improvements, will increase the yearly crops by an equivalent of many billions of dollars. The distribution of the food to the needy is a completely different problem. The question is not so much one of shipping volume, it is one of international cooperation. The ruler of a small nation may feel very uneasy about the prospect of having large quantities of food shipped into his country by a large nation, simply because he fears that along with the food there may also be an import of influence and foreign power. Efficient relief from hunger, I am afraid, will not come before the boundaries between nations have become less divisive than they are today. I do not believe that space flight will accomplish this miracle over night. However, the space program is certainly among the most promising and powerful agents working in this direction. Let me only remind you of the recent near-tragedy of Apollo 13. When the time of the crucial reentry of the astronauts approached, the Soviet Union discontinued all Russian radio transmissions in the frequency bands used by the Apollo Project in order to avoid any possible interference, and Russian ships stationed themselves in the Pacific and the Atlantic Oceans in case an emergency rescue would become necessary. Had the astronaut capsule touched down near a Russian ship, the Russians would undoubtedly have expended as much care and effort in their rescue as if Russian cosmonauts had returned from a space trip. If Russian space travelers should ever be in a similar emergency situation, Americans would do the same without any doubt. Higher food production through survey and assessment from orbit, and better food distribution through improved international relations, are only two examples of how profoundly the space program will impact life on Earth. I would like to quote two other examples: stimulation of technological development, and generation of scientific knowledge. The requirements for high precision and for extreme reliability which must be imposed upon the components of a moon-travelling spacecraft are entirely unprecedented in the history of engineering. The development of systems which meet these severe requirements has provided us a unique opportunity to find new material and methods, to invent better technical systems, to manufacturing procedures, to lengthen the lifetimes of instruments, and even to discover new laws of nature. All this newly acquired technical knowledge is also available for application to Earth-bound technologies. Every year, about a thousand technical innovations generated in the space program find their ways into our Earthly technology where they lead to better kitchen appliances and farm equipment, better sewing machines and radios, better ships and airplanes, better weather forecasting and storm warning, better communications, better medical instruments, better utensils and tools for everyday life. Presumably, you will ask now why we must develop first a life support system for our moon-travelling astronauts, before we can build a remote-reading sensor system for heart patients. The answer is simple: significant progress in the solutions of technical problems is frequently made not by a direct approach, but by first setting a goal of high challenge which offers a strong motivation for innovative work, which fires the imagination and spurs men to expend their best efforts, and which acts as a catalyst by including chains of other reactions. Spaceflight without any doubt is playing exactly this role. The voyage to Mars will certainly not be a direct source of food for the hungry. However, it will lead to so many new technologies and capabilities that the spin-offs from this project alone will be worth many times the cost of its implementation. Besides the need for new technologies, there is a continuing great need for new basic knowledge in the sciences if we wish to improve the conditions of human life on Earth. We need more knowledge in physics and chemistry, in biology and physiology, and very particularly in medicine to cope with all these problems which threaten man’s life: hunger, disease, contamination of food and water, pollution of the environment. We need more young men and women who choose science as a career and we need better support for those scientists who have the talent and the determination to engage in fruitful research work. Challenging research objectives must be available, and sufficient support for research projects must be provided. Again, the space program with its wonderful opportunities to engage in truly magnificent research studies of moons and planets, of physics and astronomy, of biology and medicine is an almost ideal catalyst which induces the reaction between the motivation for scientific work, opportunities to observe exciting phenomena of nature, and material support needed to carry out the research effort. Among all the activities which are directed, controlled, and funded by the American government, the space program is certainly the most visible and probably the most debated activity, although it consumes only 1.6 percent of the total national budget, and 3 per mille (less than one-third of 1 percent) of the gross national product. As a stimulant and catalyst for the development of new technologies, and for research in the basic sciences, it is unparalleled by any other activity. In this respect, we may even say that the space program is taking over a function which for three or four thousand years has been the sad prerogative of wars. How much human suffering can be avoided if nations, instead of competing with their bomb-dropping fleets of airplanes and rockets, compete with their moon-travelling space ships! This competition is full of promise for brilliant victories, but it leaves no room for the bitter fate of the vanquished, which breeds nothing but revenge and new wars. Although our space program seems to lead us away from our Earth and out toward the moon, the sun, the planets, and the stars, I believe that none of these celestial objects will find as much attention and study by space scientists as our Earth. It will become a better Earth, not only because of all the new technological and scientific knowledge which we will apply to the betterment of life, but also because we are developing a far deeper appreciation of our Earth, of life, and of man. The photograph which I enclose with this letter shows a view of our Earth as seen from Apollo 8 when it orbited the moon at Christmas, 1968. Of all the many wonderful results of the space program so far, this picture may be the most important one. It opened our eyes to the fact that our Earth is a beautiful and most precious island in an unlimited void, and that there is no other place for us to live but the thin surface layer of our planet, bordered by the bleak nothingness of space. Never before did so many people recognize how limited our Earth really is, and how perilous it would be to tamper with its ecological balance. Ever since this picture was first published, voices have become louder and louder warning of the grave problems that confront man in our times: pollution, hunger, poverty, urban living, food production, water control, overpopulation. It is certainly not by accident that we begin to see the tremendous tasks waiting for us at a time when the young space age has provided us the first good look at our own planet. Very fortunately though, the space age not only holds out a mirror in which we can see ourselves, it also provides us with the technologies, the challenge, the motivation, and even with the optimism to attack these tasks with confidence. What we learn in our space program, I believe, is fully supporting what Albert Schweitzer had in mind when he said: “I am looking at the future with concern, but with good hope.” My very best wishes will always be with you, and with your children. Very sincerely yours, Ernst Stuhlinger Associate Director for Science May 6, 1970","tags":["其他"]},{"title":"秋水","path":"/2023/05/09/人文/经/秋水/","content":"秋水 原文（节选） 庄子钓于濮水，楚王使大夫二人往先焉，曰：“愿以境内累矣！”庄子持竿不顾，曰：“吾闻楚有神龟，死已三千岁矣。王巾笥而藏之庙堂之上。此龟者，宁其死为留骨而贵乎？宁其生而曳尾于涂中乎？”二大夫曰：“宁生而曳尾涂中。”庄子曰：“往矣！吾将曳尾于涂中。”","tags":["人文","玄学"]},{"title":"心经","path":"/2023/05/09/人文/经/心经/","content":"心经 原文 观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。 舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。 舍利子，是诸法空相，不生不灭，不垢不净，不增不减。 是故空中无色，无受想行识，无眼耳鼻舌身意，无色声香味触法，无眼界，乃至无意识界，无无明，亦无无明尽，乃至无老死，亦无老死尽。 无苦集灭道，无智亦无得，以无所得故。 菩提萨埵，依般若波罗蜜多故，心无挂碍。无挂碍故，无有恐怖，远离颠倒梦想，究竟涅盘。三世诸佛，依般若波罗蜜多故，得阿耨多罗三藐三菩提。 故知般若波罗蜜多，是大神咒，是大明咒，是无上咒，是无等等咒，能除一切苦，真实不虚。故说般若波罗蜜多咒，即说咒曰：揭谛揭谛，波罗揭谛，波罗僧揭谛，菩提萨婆诃。","tags":["人文","佛学"]},{"title":"基于摩擦纳米发电 TENG 的刹车检测系统开发文档","path":"/2023/05/03/项目/基于摩擦纳米发电 TENG 的刹车检测系统开发文档/","content":"基于摩擦纳米发电 TENG 的刹车检测系统开发文档 目的 针对近几年经常出现的刹车失灵事件，市面上出现了一些针对踏板（刹车、油门/电门）的监控设备，主要对驾驶员的脚下操作进行记录，但市面上的设备大多都是基于摄像头来捕获驾驶员的动作，如下图所示产品： 可以说这类产品继承了摄像头的所有缺点，包括但不限于遮挡、光线、发热、存储等问题。 该项目基于这些痛点，借助摩擦纳米发电机（TENG）类似于压电效应的特性，通过驾驶员对踏板的踩踏，敏感单元将其产生的机械信号转化为电信号， 硬件开发 结构 市面上大多数汽车的踏板可分为两种 —— “地板式”（右）和“悬挂式”（左），如下图所示： 同时，不同的车型其踏板设计也必然不同，因此就需要该产品必须模块化，我们将产品分为以下几个模块： 结构单元：根据具体车型的踏板进行设计外壳（可参考国标），外壳主要功能为保护敏感单元； 敏感单元：主要功能为将驾驶员踩踏的机械信号转化为电信号； 电路单元：主要功能为采集敏感单元输出的电信号并将其无线传输到终端设备。 综上，可知，结构单元需要根据实际车型的不同来进行适配，即所谓定制化。 材料 聚甲醛 1.3 - 1.4 （接左栏） 乙基纤维素 聚酯（Dacron） 聚酰胺（尼龙）- 11 聚异丁烯 聚酰胺（尼龙）- 66 聚氨酯，柔性海绵 三聚氰胺 聚对苯二甲酸乙二醇酯（PET） 编织的羊毛 聚乙烯醇缩丁醛 编制的蚕丝 氯丁橡胶 铝 自然橡胶 纸张 聚丙烯腈 纺织的棉花 腈氯纶 钢 聚碳酸双酚 木材 聚 2，2 - 双（氢甲基）丁氧环 硬橡胶 聚偏二氯乙烯（Saran） 镍，铜 聚苯乙烯 硫 聚乙烯 黄铜，银 聚丙烯 酷酸纤维，人造纤维 聚酰亚胺（Kapton） 聚甲基丙烯酸甲酯（Lucite） 聚氯乙烯（PVC） 聚乙烯醇 聚二甲基硅氧烷（PDMS） （转右栏） 聚四氟乙烯（Teflon） 左上显正电性最强、右下显负电性最强。 电路 电路部分主要分为整流和放大两个模块。 整流 该电路模块主要作用为将摩擦纳米发电机（TENG）即敏感单元产生的交流电转化为直流电。 放大 该电路模块主要作用为放大整流后的直流电压，使其能够被单片机准确的检测到且不易被外部干扰。 软件开发 嵌入式 主控板选用 ESP32 S3 DevkitC-1，可采用 ESP-IDF 或 Arduino 框架进行开发，主要功能有： 读取经由 PCB 处理的输出信号； 将信号分解为以下几个维度； 信号持续时间 输出频率 波峰数量 波峰间隔时间（应当为数组） 峰峰值 将数据通过 WIFI 传输到 PC 端进行后期处理； 深度学习 深度学习算法主要采用 CNN 卷积神经网络对数据进行预测，下面将从数据集准备、算法编写两个方面来介绍。 数据集 如前文所说，数据集需要准备信号持续时间、输出频率、波峰数量、波峰间隔时间和峰峰值这几列数据，然后加上一个标签，例如急刹、点刹等（该分类标准有待确定）。 综上，我们可以认为一组格式正确的数据应当如下： 标签 信号持续时间 波峰数量 波峰间隔时间 峰峰值 急刹 0.3 1 [] 10.3 而所谓数据集则是由大量的上述数据构成的集合。 算法 代码的整体思路是使用卷积神经网络（CNN）对汽车刹车信号进行分类。具体来说： 它首先读取 CSV 文件并对数据进行预处理； 然后将数据划分为训练集和测试集； 接下来，它使用 TensorBoard 可视化模型，并定义、编译和检查模型； 然后，它使用测试集对模型进行测试，并输出测试损失、测试准确率和预测标签列表； 最后，它使用 Keras 的 plot_model 函数将模型结构保存为 PNG 文件。 整个代码的目的是训练一个能够准确分类汽车刹车信号的模型，并对模型进行评估和可视化。 123456import pandas as pdimport numpy as npimport tensorflow as tffrom keras import layers, modelsimport osimport datetime 这里导入了一些必要的 Python 库，包括 Pandas 用于读取 CSV 文件，NumPy 用于数据处理，TensorFlow 用于构建和训练模型，Keras 用于定义模型，os 用于文件操作，datetime 用于记录时间。 1234def read_data(file_path): &quot;&quot;&quot;读取CSV文件&quot;&quot;&quot; data = pd.read_csv(file_path) return data 这个函数用于读取 CSV 文件，它接受一个文件路径作为参数，并返回一个 Pandas DataFrame 对象。 1234567891011121314151617def preprocess_data(data): &quot;&quot;&quot;预处理数据&quot;&quot;&quot; # 将&quot;波峰间隔时间&quot;列转换为列表 data[&#x27;波峰间隔时间&#x27;] = data[&#x27;波峰间隔时间&#x27;].apply(lambda x: [float(i) for i in x.strip(&#x27;[]&#x27;).split()]) # 将标签列转为数字编码 label_map = &#123;&#x27;急刹&#x27;: 0, &#x27;点刹&#x27;: 1&#125; data[&#x27;标签&#x27;] = data[&#x27;标签&#x27;].map(label_map) # 将&quot;波峰间隔时间&quot;一栏单独填充 padded_intervals = tf.keras.preprocessing.sequence.pad_sequences(data[&#x27;波峰间隔时间&#x27;].tolist(), maxlen=10, dtype=&#x27;float32&#x27;, padding=&#x27;post&#x27;, truncating=&#x27;post&#x27;) # 将填充的&quot;波间隔时间&quot;列与其他列结合起来 data[[&#x27;信号持续时间&#x27;, &#x27;波峰数量&#x27;, &#x27;峰峰值&#x27;]] = data[[&#x27;信号持续时间&#x27;, &#x27;波峰数量&#x27;, &#x27;峰峰值&#x27;]].to_numpy(dtype=&#x27;float32&#x27;) combined_data = np.hstack((data[[&#x27;信号持续时间&#x27;, &#x27;波峰数量&#x27;, &#x27;峰峰值&#x27;]].to_numpy(), padded_intervals)) return combined_data 这个函数用于对数据进行预处理，它接受一个 Pandas DataFrame 对象作为参数，并返回一个 NumPy 数组。在这个函数中，我们将波峰间隔时间列转换为列表，并将标签列转换为数字编码。然后，我们使用 Keras 的 pad_sequences 函数对波峰间隔时间列进行填充，使其长度为10。最后，我们将填充后的波峰间隔时间列与其他列合并，并返回一个 NumPy 数组。 12345def split_data(data, train_ratio=0.8): &quot;&quot;&quot;划分训练集测试集&quot;&quot;&quot; train_data = data[:int(len(data)*train_ratio)] test_data = data[int(len(data)*train_ratio):] return train_data, test_data 这个函数用于将数据划分为训练集和测试集，它接受一个 NumPy 数组作为参数，并返回两个 NumPy 数组，分别表示训练集和测试集。默认情况下，它将数据的80％用于训练，20％用于测试。 12345678910def create_model(): &quot;&quot;&quot;定义CNN模型&quot;&quot;&quot; model = models.Sequential([ layers.Conv1D(32, 3, activation=&#x27;relu&#x27;, input_shape=(13, 1)), layers.MaxPooling1D(2), layers.Flatten(), layers.Dense(64, activation=&#x27;relu&#x27;), layers.Dense(2, activation=&#x27;softmax&#x27;) ]) return model 这个函数用于定义 CNN 模型，它返回一个 Keras 模型对象。在这个模型中，我们使用了一个卷积层，一个最大池化层，一个展平层，两个全连接层和一个 softmax 层。输入形状为（13，1），表示有 13 个特征和 1 个通道。 123456def compile_model(model): &quot;&quot;&quot;编译模型&quot;&quot;&quot; model.compile(optimizer=&#x27;adam&#x27;, loss=&#x27;sparse_categorical_crossentropy&#x27;, metrics=[&#x27;accuracy&#x27;]) return model 这个函数用于编译模型，它接受一个 Keras 模型对象作为参数，并返回编译后的模型。在这个函数中，我们使用了 Adam 优化器，稀疏分类交叉熵损失和准确率指标。 12345678910def check_model_file(model, train_data, tensorboard_callback): &quot;&quot;&quot;检查模型文件是否存在，如果存在则加载模型，否则训练模型并保存&quot;&quot;&quot; if os.path.exists(&#x27;model/model.h5&#x27;): model.load_weights(&#x27;model/model.h5&#x27;) else: x_train = train_data[:, :, np.newaxis] y_train = train_data[:, -1].astype(int) model.fit(x_train, y_train, epochs=10, callbacks=[tensorboard_callback]) model.save_weights(&#x27;model/model.h5&#x27;) return model 这个函数用于检查模型文件是否存在，如果存在则加载模型，否则训练模型并保存。它接受一个 Keras 模型对象、一个训练集 NumPy 数组和一个 TensorBoard 回调对象作为参数，并返回训练好的模型。如果模型文件存在，则加载模型权重；否则，将训练集输入到模型中进行训练，并保存模型权重。 123456def evaluate_model(model, test_data): &quot;&quot;&quot;测试模型&quot;&quot;&quot; x_test = test_data[:, :, np.newaxis] y_test = test_data[:, -1].astype(int) test_loss, test_acc = model.evaluate(x_test, y_test) return test_loss, test_acc 这个函数用于测试模型，它接受一个 Keras 模型对象和一个测试集 NumPy 数组作为参数，并返回测试损失和测试准确率。 12345678def predict_labels(model, test_data, label_map): &quot;&quot;&quot;输出预测结果&quot;&quot;&quot; x_test = test_data[:, :, np.newaxis] predictions = model.predict(x_test) predicted_labels = [list(label_map.keys())[list(label_map.values()).index(np.argmax(prediction))] for prediction in predictions] print(&quot;模型的预测结果：&quot;, predictions) print(&quot;标签映射：&quot;, label_map) return predicted_labels 这个函数用于输出模型的预测结果，它接受一个 Keras 模型对象、一个测试集 NumPy 数组和一个标签映射字典作为参数，并返回预测标签列表。在这个函数中，我们使用模型对测试集进行预测，并将预测结果转换为标签列表。 123456789101112131415161718192021222324252627def main(): file_path = &#x27;data/1.csv&#x27; data = read_data(file_path) combined_data = preprocess_data(data) train_data, test_data = split_data(combined_data) # 使用TensorBoard可视化模型 log_dir = &quot;logs/fit/&quot; + datetime.datetime.now().strftime(&quot;%Y%m%d-%H%M%S&quot;) tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1) model = create_model() model = compile_model(model) model = check_model_file(model, train_data, tensorboard_callback) test_loss, test_acc = evaluate_model(model, test_data) print(&quot;Test loss:&quot;, test_loss) print(&quot;Test accuracy:&quot;, test_acc) label_map = &#123;&#x27;急刹&#x27;: 0, &#x27;点刹&#x27;: 1&#125; predicted_labels = predict_labels(model, test_data, label_map) print(predicted_labels) tf.keras.utils.plot_model(model, to_file=&#x27;model/model.png&#x27;, show_shapes=True) returnif __name__ == &#x27;__main__&#x27;: main() 这个函数是主函数，它调用了前面定义的所有函数来完成模型的训练和测试。在这个函数中，我们首先读取 CSV 文件并对数据进行预处理，然后将数据划分为训练集和测试集。接下来，我们使用 TensorBoard 可视化模型，并定义、编译和检查模型。然后，我们使用测试集对模型进行测试，并输出测试损失、测试准确率和预测标签列表。最后，我们使用 Keras 的 plot_model 函数将模型结构保存为 PNG 文件。","tags":["项目","文档"]},{"title":"AnyCloud37E 开发指南","path":"/2023/04/28/技术/嵌入式/AnyCloud37E 开发指南/","content":"AnyCloud 37 E 开发指南 一、准备 物品清单： 开发板（屏幕、摄像头、SDIO WIFI 小板）× 1； UART 转 Type A 数据线 × 1； Micro-B 转 Type A 数据线 × 2； 二、启动 找到带有“DC 电源座”字样的 USB 插口，插入 Micro-B 数据线，另一端插入电脑或者电源； 找到 SW 1 电源开关按钮，按下按钮即供电开机； 三、配置 在配置交叉编译环境之前，需要先在电脑上装一个 Ubuntu 系统，这里提供两种思路： VMware 虚拟机或者 VirtualBox 虚拟机 Windows Subsystem For Linux（WSL） 具体的安装方法可以自己去查阅。 系统安装完成之后，需要安装编译环境，具体安装命令有： 12345678910111213sudo apt-get install gcc-multilibsudo apt-get install libstdc++6sudo apt-get install make cmakesudo apt-get install zlib1g-dev lib32z1-devsudo apt-get install liblzo2-dev liblzo2-2 liblzo2-dev:i386sudo apt-get install u-boot-toolssudo apt-get install lib32ncurses6 libncurses5-devsudo apt-get install libmpfr-dev libmpfr6 libmpfr6:i386sudo apt-get install mtd-utilssudo apt-get install libtoolsudo apt-get install cpp g++sudo apt-get install gawksudo apt-get install gcc perl 如果安装之后还有报错缺少什么东西，根据报错的内容去安装对应的包即可。 在编译之前，我们还需要将交叉编译器添加到环境变量中，理论上，交叉编译器应当位于 SDK 的 tool 文件夹下的 arm-anykav500-linux-uclibcgnueabi 压缩包内，只需要执行 tar xvf arm-anykav500-linux-uclibcgnueabi.tar.bz2 解压压缩包，里面的 bin 目录就是交叉编译器的所在目录了，将该 bin 目录的绝对路径添加到环境变量即可。如果想就只使用一次，可以执行 export PATH=$PATH:这里改为你的交叉编译器路径 以设置临时变量，如果想设置永久变量，可以前面的命令放到 ~/.bashrc 文件的最后一行，这样每次打开一个 Shell 都会设置一遍环境变量。 四、编译 解压官方给的压缩包文件（或者去我的 Github 仓库下载），找到 AK37E_SDK_V1.05.tar.gz 文件，使用 tar xvf AK37E_SDK_V1.05.tar.gz 命令来解压 SDK，解压完成之后，找到 auto_build.sh 文件，运行该文件即可成功编译。 需要注意的是，使用 auto_build.sh 脚本自动化编译可能会导致难以看出是哪一部分出现了报错，所以如果编译脚本很快就执行结束了， 可能会出现 error while loading shared libraries:libmpfr.so.4: cannot open shared object file: No such file or directory. 一个链接库无法链接的问题，运行 sudo ln -s /usr/lib/x86_64-linux-gnu/libmpfr.so.6 /usr/lib/x86_64-linux-gnu/libmpfr.so.4 命令即可。 五、烧录 在烧录之前，确保开发板上的 JP 1 和 JP 2 跳线已配置为 USB_DP -&gt; AK_DP，USB_DM -&gt;AK_DM； 在电脑上（Windows 系统）运行 Burn Tool 工具，暂不需要改动配置； 用数据线插上开发板上带有“串口”字样的 Micro-B 接口，另一头插入电脑； 打开 Burn Tool 烧录软件，按下开发板的 BOOT 按钮，不要松手，然后短按 RESET 按钮一次，等待 Burn Tool 软件设备 0 通道变黄，然后点击开始，便可开始烧录； 六、调试 在供电的同时，使用 USB 转 UART 数据线连接电脑与开发板，启动 MobaXterm，找到对应的串口号，选择 Shell 进行连接； 按下开发板的 RESET 按键，要求输入用户名和密码： 用户名：root 密码为空，回车即可 操作过程会一直弹出 udhcpc:，这是应为没有网络连接导致，可通过 killall udhcpc 命令来终止这个进程； 七、LCD 开发 1. 视频（图像）文件转换 由于该开发板 LCD 屏幕不能直接显示 JPG、PNG 或 MP 4 等常见文件，我们需要借助工具来将这些文件转化为该 LCD 支持的 RGB 或 YUV 等格式（具体内容请见《中间件接口说明》文档“视频输出”部分）。 在本文中我们将借助 FFmpeg 工具来执行格式转换工作： Windows：在 Microsoft Store 中直接下载即可； Linux：各大 Linux 发行版基本都可以直接通过包管理器安装 FFmpeg，例如 Debian 系的 Ubuntu 可以使用 sudo apt install ffmpeg 进行安装，Arch 系可以使用 sudo pacman -S ffmpeg 进行安装。 安装完成之后，就可以在命令行中使用 FFmpeg 了（该软件没有 GUI 图形界面）。 // todo 首先我们创建一个名为 image 的文件夹和一个 yuv 文件夹（其实随便什么名字都可以），然后使用 ffmpeg -i input.mp4 -r 10 -f image2 yuv/%05d.yuv 命令将 input. Mp 4 分解成一帧一帧的 yuv 文件且保存在 yuv 文件夹下。 通过以上操作，我们得到了一个名为 yuv 的文件夹，且该文件夹内容为 input. Mp 4 视频的逐帧 yuv 文件。 2. 挂载 TF 卡 因为开发板的存储空间非常小且是只读的，所以我们无法通过烧录的形式将上述的 yuv 文件夹导入开发板内部存储器中，因此我们需要借助 TF 卡这一外部存储器。 首先我们将 TF 卡插入读卡器然后接入到 PC 中，将 yuv 文件夹复制到 TF 卡内，然后将 TF 卡插到开发板上即可。 开发板启动之后，登录进入系统，运行 tf_card.sh 来加载相关驱动，然后查看 /dev 目录下有无 mmcblk0p1 文件，如果有就算是识别出来 TF 卡了，紧接着执行 mount /dev/mmcblk0p1 /mnt 将 TF 卡挂载到 /mnt 目录下，这样我们就能在 /mnt 目录下读写 TF 卡内的文件了。 3. 显示图像 在让屏幕显示图像之前，我们还需要加载屏幕相关驱动，具体步骤为： 进入 /usr/modules 目录内； 执行 insmod ak_fb.ko 和 insmod ak_gui.ko。 屏幕驱动加载完毕后，进入 /usr/bin 目录下，找到 ak_vo_sample 程序，该程序的作用就是在屏幕上输出视频或图像，使用 ak_vo_sample -h 命令可查看帮助信息。 输出帮助信息后，能够看到 ak_vo_sample -w 1024 -e 600 -x 0 -r 1920 -s 1080 -f /mnt/yuv -n 1 -i 4 -o 1 -l /mnt/anyka.logo.577.160.rgb 这一条示例命令。在这条命令中我们只需要将 /mnt/anyka.logo.577.160.rgb 替换为 /mnt/yuv 目录下的任一文件名即可，也可以执行 ak_vo_sample -w 1024 -e 600 -x 0 -r 1920 -s 1080 -f /mnt/yuv -n 1 -i 4 -o 1 -l /mnt/yuv*。 注： 前提是你的 /mnt 目录下已经按照上文要求的放置好了 yuv 文件夹。 执行完该命令之后便可以看到屏幕中出现一帧一帧的动态图像了。","tags":["Linux","嵌入式"]},{"title":"欧拉角与四元数","path":"/2023/02/03/理论/欧拉角与四元数/","content":"欧拉角与四元数 欧拉角 简介 简单来说，欧拉角就是物体绕坐标系的三个坐标轴（X,Y,ZX, Y, ZX,Y,Z）的旋转角度，可以用于表示刚体当前的姿态。如下图所示： 图片中即为上述的三次旋转（其实可以绕某一轴，一次旋转即可达到最终位置）。 在这里，坐标系可以是 世界坐标系（xyzxyzxyz），也可以是 刚体坐标系 （XYZXYZXYZ），它的旋转顺序也是任意的。 欧拉角可以分成两种情况： 静态：绕 世界坐标系 （xyzxyzxyz）三个轴的旋转，由于 物体旋转过程中坐标轴保持静止，所以称为静态； 动态：绕 刚体坐标系 （XYZXYZXYZ）三个轴的旋转，由于 物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。 上图具体的旋转步骤为： 绕 世界坐标系 的 zzz 轴，旋转 α\\alphaα 度； 绕 刚体坐标系 的 XXX 轴，旋转 β\\betaβ 度； 绕 刚体坐标系 的 ZZZ 轴，旋转 γ\\gammaγ 度。 欧拉角遵循的是 右手坐标系，即大拇指指向坐标轴正方向，四指旋转的方向即为转动的正方向，欧拉角包含三个自由量：Yaw（偏航角）、 Pitch （俯仰角）、Roll（翻滚角），相当于有三个独立变量（自由度）控制一架飞机进行如下旋转操作： 如何区分 Roll、Pitch、Yaw？ 首先应先给定物体一个姿态，就是确定其前后、左右、上下，这样就能对应 Roll、Pitch、Yaw。结合建立在物体上的坐标系，就可以搞定了。 绕着 前后 轴（Front-to-Back Axis）旋转角度为 Roll； 绕着 左右 轴（Side-to-Side Axis）旋转角度为 Pitch； 绕着 竖直 轴（Vertical Axis）旋转角度为 Yaw。 Tips： 在物体上可以随意建立坐标系，这就意味着坐标轴的方向也是可以随意设定，因此仅仅说绕着某个坐标轴旋转就是 Pitch 在另一个坐标系中可能就不适用。 先确定坐标系，然后绕固定坐标轴的旋转确定 Roll、Pitch、Yaw 的方式在特定的场合或领域是非常方便的，比如在航空、航海等，尤其是对于刚刚接触新手来说，死记硬背就好了，在这个圈里混，规矩就是这。 对于有些场合，比如医疗器械、游戏开发等，绕某个轴旋转方式确定 Roll、Pitch、Yaw 就会带来一些理解上的问题。 上面动图旋转步骤为 z→Y→Xz \\rightarrow Y \\rightarrow Xz→Y→X ，按照顺序标记为 zYXzYXzYX ，加上角度即为一个完整欧拉角： zYX−(ψ,θ,ϕ)zYX - (\\psi, \\theta, \\phi) zYX−(ψ,θ,ϕ) 右手坐标系 如上所述，欧拉角遵循的是 右手坐标系，那么与之相对的肯定有左手坐标系，左手坐标系与右手坐标系最大的区别就是，如果将这两个坐标系的两个轴方向对齐，那么另一个轴的方向必定相反，因为左手坐标系目前我还没有用过，所以这里只列出右手坐标系的判断规则。如下图所示： 万向节死锁 万向节死锁发生在欧拉角形式下，是由欧拉旋转定义本身造成的。 当任何一个坐标轴旋转角度为 90 度时，就会有两个轴的旋转动作起到对总体旋转结果相同的效果，这就被称为“死锁”，动图如下所示： 1. 翻滚 2. 俯仰 3. 偏航 4. 死锁 现在看起来，这个陀螺仪一切正常，在船体发生任意方向摇晃都可以通过自身调节来应对。然而，真的是这样吗？ 假如，船体发生了剧烈的变化，此时船首仰起了 90 度，此时的陀螺仪调节状态如下图： 现在，转子不平衡了，陀螺仪的三板斧不起作用了。它失去了自身的调节能力。那么这是为什么呢？ 之前陀螺仪之所以能通过自身调节，保持平衡，是因为存在可以相对旋转的连接头。在这种情况下，已经不存在可以相对旋转的连接头了。 那么连接头呢？去了哪里？显然，它还是在那里，只不过是，连接头可以旋转的相对方向不是现在需要的按着 +Z+Z+Z 轴方向。从上图中，我们清楚地看到： 红色连接头：可以给予一个相对俯仰的自由度。 绿色连接头：可以给予一个相对偏航的自由度。 蓝色连接头：可以给予一个相对偏航的自由度。 没错，三个连接头，提供的自由度只对应了 俯仰 和 偏航 两个自由度，翻滚 自由度丢失了。这就是陀螺仪上的“万向节死锁”问题。 总结来说，欧拉角的“万向节死锁”问题，是由于欧拉旋转定义本身造成的。这种围绕选旋转前固定轴的先 ZZZ、再 XXX、再 YYY 的旋转操作，与其最终所预期的三个轴向可以旋转的结果并非一定是一对一的映射。某些情况下是多对一的映射，造成一些旋转自由度的缺失，也就是“死锁”。 在编程中很难规避死锁，所以现在更多使用四元数形式进行姿态表示与旋转。 四元数 q=w+xi+yj+zkq = w + xi + yj + zk q=w+xi+yj+zk quaternion.pdf (krasjet.github.io) Quaternions - Visualisation Visualizing quaternions | 3blue1brown + Ben Eater 四元数转欧拉角 [ϕθψ]=[arctan⁡2(q0q1+q2q3)1−2(q12+q22)arcsin⁡(2(q0q2−q3q1))arctan⁡2(q0q3+q1q2)1−2(q22+q32)]\\left[\\begin{array}{c} \\phi \\\\ \\theta \\\\ \\psi \\end{array}\\right]=\\left[\\begin{array}{c} \\arctan \\frac{2\\left(q_{0} q_{1}+q_{2} q_{3}\\right)}{1-2\\left(q_{1}^{2}+q_{2}^{2}\\right)} \\\\ \\arcsin \\left(2\\left(q_{0} q_{2}-q_{3} q_{1}\\right)\\right) \\\\ \\arctan \\frac{2\\left(q_{0} q_{3}+q_{1} q_{2}\\right)}{1-2\\left(q_{2}^{2}+q_{3}^{2}\\right)} \\end{array}\\right] ​ϕθψ​​=​arctan1−2(q12​+q22​)2(q0​q1​+q2​q3​)​arcsin(2(q0​q2​−q3​q1​))arctan1−2(q22​+q32​)2(q0​q3​+q1​q2​)​​​","tags":["数学"]},{"title":"IMU 简介","path":"/2023/02/03/理论/IMU 简介/","content":"IMU 简介 所谓 IMU（Inertial Measurement Unit，简称：IMU）是指惯性测量单元，利用惯性的变化测量物体加速运动和旋转。其中目前主流的惯性测量器件是 MEMS（微机电）传感器，它将用于机械结构缩小至纳米尺度，可测量机器人加速度与旋转角速度。 需要注意的是，IMU 或者说 6 轴（6 DOF）传感器讨论的是三轴加速度计和三轴角速度计（俗称陀螺仪），与 AHRS（航姿参考系）或者说 9 轴（9 DOF）传感器是有区别的，后者增加了磁力计，以地磁场作为参考。但是在地面机器人运动并且夹杂大量电机磁干扰的情况下，引入微弱的地磁作为绝对航向并不是一个好主意。 IMU 应用 应用惯性测量 假如一个小车处于静止状态，随后以 加速度 aaa 开始加速，那么经过时间 ttt 之后，我们可以通过将加速度 aaa 对时间 ttt 进行积分从而得到小车说运动的路程 sss，即 s=12a⋅t2s = \\frac{1}{2} a \\cdot t^2s=21​a⋅t2；小车在某一点转弯，如果我们知道小车转弯的 角速度 ω\\omegaω，那么我们通过 θ=ω⋅Δt\\theta = \\omega \\cdot \\Delta tθ=ω⋅Δt 便可以求出小车转弯的角度。 因此，由上可知，我们只需要知道一个物体的加速度和角速度，就可以推算出物体的实时位姿。 多传感器融合 IMU 有时会与电机编码器进行惯导融合，能够更精准的检测小车的速度和运动轨迹；还可以与相机进行视觉融合 VIO。 IMU 数据能够和很多的传感器数据进行 融合，融合可以从空间和时间两个方面来解释： 从空间方面，IMU 数据能够和不同维度的数据（例如相机的图像数据）进行互补； 从时间方面，IMU 数据的频率很高，可以弥补低频率的传感器（例如相机）数据不够连贯的不足。 IMU 组成与原理 IMU 可根据 DOF 的不同来加以区分，其中 6 DOF 的 IMU 和 9 DOF 的 IMU 比较常见，6 DOF 的 IMU 一般由一个三轴加速度计和一个三轴陀螺仪组成。9 DOF 的 IMU 会多一个三轴磁力计。模块所能感知状态量的个数即为 DOF 大小，DOF 越多、精度越高的 IMU 也就越贵。这里只讨论 6 DOF 的 IMU。 MPU6050 是 InvenSense 公司推出的一款高性能三轴加速度 + 三轴陀螺仪的六轴传感器芯片， 该芯片内部整合了 3 轴陀螺仪和 3 轴加速度传感器，并可利用自带的 数字运动处理器（Digital Motion Processor，简称：DMP）硬件加速引擎，体积较小，减少了大量的封装空间。主要特性如下： 6 位 ADC 和信号调理的三轴 MEMS 陀螺仪，具有 131 LSBs/° /sec 敏感度与全格感测范围为 ±250、±500、±1000 与 ±2000°/sec 的 3 轴角速度感测器(陀螺仪)； 16 位 ADC 和信号调理的三轴 MEMS 加速度计，范围为 ±2g、±4g、±8g 和 ±16g 的 3 轴加速度传感器； 自带数字运动处理（Digital Motion Processing，简称：DMP）引擎，内建运作时间偏差与磁力感测器校正演算技术，以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数、欧拉角格式的融合演算数据，可减少 MCU 复杂的融合演算数据、感测器同步化、姿势感应等的负荷； VDD 供电电压为 2.5V±5%、 3.0V±5%、 3.3V±5%； VLOGIC 可低至 1.8V±5%； 陀螺仪工作电流：5mA，陀螺仪待机电流：5uA；加速度计工作电流：500uA，加速度计省电模式电流：40uA@10Hz； 支持最高 400Khz 的 IIC 通信，IIC 地址为 0X68（AD0 接 GND）或 0x69（AD0 接 VDD）； 加速度计 顾名思义，三轴加速度计能感受三轴的加速度，如上图中三个矢量所示。但要注意的是，当图示模块水平放置且静止，zzz 轴方向加速度大小为 −g-g−g，也就是说 IMU 测量的加速度与物体真实加速度相差一个重力加速度。 加速度计的物理实现是利用牛顿第二定律，如上图所示，中间红色物体为一个质量块，两头通过具有弹簧性质的长条结构与基底相连，红色的短栅与绿色的短栅分别为电容的极板。当基底在双箭头方向有加速度 aaa 时，由 f=ma=kxf=ma=kxf=ma=kx，质量块会沿加速度相反的方向移动，红色极板与绿色极板之间的距离会发生变化，通过测量极板电容 CCC 的变化就可以得到加速度的大小。在三轴加速度计中，这样的结构在三个方向各有一个，且做到了微米的尺寸，并配合相应的测量电路集成在一个芯片中（如图一所示），构成一个微机电系统（MEMS）。 陀螺仪 角速度测量的原理比加速度要复杂一些，因为涉及了 科里奥里力（Coriolis Force）。所以我们先来说一下 Coriolis Force 。科里奥里力是由坐标系的转动与物体在动坐标系中的相对运动引起的，其本质是物体的惯性。 如果图示模块置于绝对静止的坐标系中，当在 xxx 方向施加一个驱动力使质量块运动时，根据牛顿第二定律，质量块只会在 xxx 方向上运动，而在 yyy 方向上不会运动。 但如果将图示模块置于一个旋转坐标系下，由于坐标系的旋转，使得当质量块沿 xxx 方向运动时，在 yyy 方向上会受到一个力，即科里奥里力 F=−2mvωF = -2mv \\omegaF=−2mvω，从而使质量块沿 yyy 方向运动。地球上的很多自然现象，如热带气旋、季风带、河道两侧冲刷程度不同，都源于科里奥里力。 陀螺仪的物理实现如上图所示，外侧的蓝色与黄色部分为驱动电极，内部的红色与蓝色为测量电极。在模块的驱动方向施加正弦驱动电压，当模块发生旋转时，质量块在垂直方向受科里奥里力影响也会产生一个正弦运动，且正弦运动的幅值与平台的角速度成正比，通过垂直方向的电极测量出此幅值，便可以得到模块角速度。与三轴加速度计一样，这样的结构在三轴陀螺仪的三个方向上各有一个，从而测量出三个方向的角速度。 IMU 姿态解算 现在我们能够从 IMU 中得到三轴的加速度和三轴的角速度，接下来就要从这些数据中解算出三个方向的角度。实际上，单独由加速度计或陀螺仪都可以解算出三轴的角度。 由加速度解算角度 由于 加速度计本质是测量力，所以在传感器静止的时候，测量的结果为重力加速度。当平台运动的加速度远小于重力加速度时，可认为传感器测量的结果全部为重力加速度，因此可以根据重力加速的在三轴分量的大小来解算出角度。 以上图为例，传感器沿 yyy 方向倾斜的角度为： AngleAccel=arccosaxgAngle_{Accel} = arccos \\frac{ax}{g} AngleAccel​=arccosgax​ 由陀螺仪解算角度 由角速度解算角度很容易理解，当知道陀螺仪的初始角度时，对角速度进行积分就可以得到角度值： AngleGyro=Angle0+∫0tGyro dtAngle_{Gyro} = Angle_0 + \\int^t_0 Gyro \\ dt AngleGyro​=Angle0​+∫0t​Gyro dt 数据融合 现在我们可以从加速度和角速度分别解算出角度，但这两种方式都存在很大的问题。一方面由于加速度计容易受到振动的影响，噪声很大，所以解算角度的噪声也很大；另一方面虽然陀螺仪测量角速度的噪声不是很大，经过积分环节后噪声进一步被变小，但由于初始角度并不能准确得到，而且角速度存在零漂问题（即模块静止时角速度不完全为 0，而是有一个偏置），经过积分后这个误差会被累积。 因此，两种方式解算出来的角度都无法直接使用，但我们可以采用数据融合的方法，把两种角度融合在一起，得到一个既没有累计误差、噪声又小的角度数据。 1. 互补滤波 一阶互补滤波是最简单但却非常实用的数据融合算法，它把由加速度解算的角度和由角速度积分的角度按照一定比例加到一起，公式如下： Angle=K⋅AngleAccel+(1−K)⋅(Angle+ω⋅dt)Angle = K \\cdot Angle_{Accel} + (1 - K) \\cdot (Angle + \\omega \\cdot dt) Angle=K⋅AngleAccel​+(1−K)⋅(Angle+ω⋅dt) 其中参数 KKK 表示对加速度解算角度的置信程度，由于加速度的噪声很大，所以参数 KKK 一般很小，典型值为 0.050.050.05，实际使用要根据效果来调整。 这样的互补滤波器可以看做是一个高通滤波和一个低通滤波的叠加：公式的第一项是为低通滤波部分，目的是滤除加速度的噪声；公式的第二项为高通滤波部分，目的是滤除角速度的直流偏置（零漂）。 2. Kalman 滤波 待补充","tags":["IMU","传感器"]}]